---
title: 限流算法
prev:
  text: 限流算法
  link: /algorithm/domain/限流算法.md
next:
  text: 限流算法
  link: /algorithm/domain/限流算法.md
---
::: info
&#8195;&#8195;限流的主要目的是通过限制并发访问数量或者限制一个时间窗口内允许处理的请求数量来保护系统，一旦达到限制数量则对当前请求进行处理采取对应的拒绝策略，比如跳转到错误页面拒绝请求进入、排队、降级等等。

&#8195;&#8195;限流的主要作用是损失一部分用户的可用性，为大部分用户提供可靠的服务。要实现限流，最重要的是限流算法，常见的限流算法有四种：计数器算法、滑动窗口算法、令牌桶算法、漏桶算法。
:::
[[toc]]
***

## 计数器算法

### 原理
&#8195;&#8195;计数器算法是一种比较简单的限流算法，在指定的周期内累加访问次数，当访问次数达到设定的阈值时，触发限流政策。当进入下一个时间周期时，访问次数清零重新计数。

&#8195;&#8195;如图，先顶了每一分钟能够处理的总请求数是100，在第一个1min内，一共请求60次，在第二个1min内，counter从0开始重新计数，在时间刚到一半时达到请求阈值，这时候所有的请求都会被拒绝。

![计数器算法](/images/algorithm/domain/计数器算法.png)


### 伪代码实现
&#8195;&#8195;这种算法比较适合于场景简单的限流场景，比如短信发送的频次限制上，比如限制同一个用户1min内只能发送一次短信。下面是算法实现的伪代码：

```java
public class Counter {
    public long timestamp = System.currentTimeMillis(); //当前时间
    public int reqCount = 0; //初始化计数器
    public final int limit = 100; // 时间窗口内最大请求数
    public final long intervel = 1000 * 60; //时间窗口 1min


    public boolean limit() {
        long now = System.currentTimeMillis();
        if (now < timestamp + intervel) {
            reqCount ++;
            return  reqCount <= limit;
        } else {
            timestamp = now;
            reqCount = 1; // 超时重置
            return true;
        }
    }
}
```

&#8195;&#8195;**计数器算法存在一个临界问题**。比如还是上面的例子，在0:58-1:02之内分别出现了100个请求，整体看则是这4s内就出现了超过阈值200的请求。

![计数器算法临界问题](/images/algorithm/domain/计数器算法临界问题.png)

## 滑动窗口算法

### 原理
&#8195;&#8195;为了解决计数器算法的临界问题，引入了滑动窗口算法。滑动窗口是一种流量控制技术，在TCP网络通信协议中，就采用了滑动创空算法来解决网络拥塞问题。

&#8195;&#8195;简单来说，滑动窗口算法就是在固定的窗口中分割出多个小时间窗口，分别在每个时间窗口中记录访问次数，然后根据时间将窗口往前滑动并且删除过期的小时间窗口。最终只统计滑动窗口范围内的所有小时间窗口总的计数即可。

&#8195;&#8195;如图所示，将计数器算法的时间窗口拆分为4个小时间窗口，每个小时间窗口只能处理25个请求。并且通过虚线框表示滑动窗口的大小(下图所示的滑动窗口是2，最多只能处理50个请求)。同时滑动窗口会向前移动，比如在15s结束后，滑动窗口移动到15s-45s的范围内，然后在新的窗口中重新统计数据。

&#8195;&#8195;**滑动窗口算法可以很好地解决计数器算法的临界问题**。但是滑动时间窗口算法也不是精确地，小时间窗口划分的越多，精确度越高。但是小时间窗口划分的越多，占用的存储空间越大，因此需要根据实际的需求判断用空间换精度还是舍弃一定精度换空间。

![滑动窗口算法](/images/algorithm/domain/滑动窗口算法.png)

### 伪代码实现

&#8195;&#8195;由上面的原理可见，我们要实现一个滑动时间窗口算法，大致需要完成3个内容：
- **载体**：时间间隔计数器，每一个时间间隔内我们都需要保存一个计数器来记录请求相关信息
- 流程：
  1. **滑动时间窗口**：不同的请求落在了线性的时间间隔内，我们需要根据请求的时间和时间间隔的开始时间，判断时间窗口的滑动位置。
  2. **请求数据计算和统计**：为每一个时间间隔创建计数器，统计其自身间隔内的请求数据并对限流状态做出相应的改变。
```java
public class SlidingTimeWindow {
    Long counter = 0L;
    LinkedList<Long> slots = new LinkedList<Long>(); // 使用LinkedList记录滑动时间窗口内的10个槽位

    private void doCheck() {
        while (true) {
            slots.addLast(counter);
            if (slots.size() > 10) {
                slots.removeFirst();
            }

            // 比较最后一个和第一个，超过100即限流
            if ((slots.peekLast() - slots.peekFirst()) > 100) {
                System.out.printf("被限流了");
                // todo 限流标记修改为true
            } else {
                // todo 限流标记修改为 false
            }
        }
    }

    public static void main(String[] args) {
        SlidingTimeWindow timeWindow = new SlidingTimeWindow();
        new Thread(()-> {
            timeWindow.doCheck();
        }).start();

        while (true) {
            timeWindow.counter ++;
        }
    }
}
```

## 令牌桶算法

### 原理
&#8195;&#8195;n，对于每一个请求，都需要从令牌桶中获得一个令牌，如果没有获得令牌，则触发限流策略。

&#8195;&#8195;如图所示，系统会以恒定的速率往固定容量的令牌桶中放入令牌，如果此时客户端请求进来，则需要先从桶中拿到令牌来获得访问资格。

![令牌桶算法](/images/algorithm/domain/令牌桶算法.png)

&#8195;&#8195;假设令牌的生成速度是10s/个，也就是QPS=10，此时请求获取令牌的时候会存在三种情况：
- 请求速度大于令牌生成速度：令牌很快被取完，后续的请求被限流。
- 请求速度等于令牌生成速度：流量处于平稳状态。
- 请求速度小于令牌生成速度：系统的并发数不高，请求被正常处理。


&#8195;&#8195;**由于令牌桶是固定容量，如果请求速度小于令牌生成速度，令牌桶会被填满。所以令牌桶能够处理突发流量，也就是短时间内新增的系统流量能够正常处理**。

### 伪代码实现
&#8195;&#8195;实现令牌桶算法，需要以下三个指标：
- 桶容器大小
- 令牌生产速度
- 当前令牌数量

```java
public class TokenBucket {
    public long timeStamp = System.currentTimeMillis(); // 当前时间
    public long capacity; // 桶的容量
    public long rate; // 令牌放入速度
    public long tokens; // 当前令牌数量
    public boolean grant() {
        long now = System.currentTimeMillis();
        tokens = Math.min(capacity, tokens + (now - timeStamp) * rate);
        timeStamp = now;
        if (tokens < 1) {
            // 若不到1个令牌,则拒绝
            return false;
        } else {
            // 还有令牌，领取令牌
            tokens -= 1;
            return true;
        }
    }
}
```
## 漏桶算法
### 漏桶算法原理
&#8195;&#8195;漏桶算法主要作用是控制数据注入网络的速度，平滑网络上的突发流量(削峰)。

&#8195;&#8195;如图所示，漏桶算法也是维护一个容器，水龙头就是clinet端源源不断的请求，这个容器会以恒定的速度流出水，也就是会按照恒定的速度通过请求，**不管请求数量多少，pass的请求数量是恒定的，同时桶的容量也是有限的，满了也不能再有请求进入了，需要等流出后才有新的再进来**。这但很像消息中间件，不管生产者的请求量多大，消息的处理能力取决于消费者的消费能力。

![漏桶算法](/images/algorithm/domain/漏桶算法.png)

&#8195;&#8195;在漏桶算法中，存在一下几种情况：
- 请求速度大于漏桶流出的速度：即请求数量超过当前服务的处理能力，触发限流政策。
- 请求速度小于或者等于桶流出的速度：满足客户端的处理速度，请求可以正常执行。

&#8195;&#8195;**漏桶算法与令牌桶算法的实现原理相差不大，最大区别是漏桶算法无法处理短时内流量突发的情况，是一种恒定速度的限流算法**。

### 伪代码实现
&#8195;&#8195;实现漏桶算法，我们需要有以下几点指标：
- 主要指标：
  - 桶的容量
  - 流速(每秒能够处理的请求数量)
  - 当前请求数量统计
- 逻辑顺序：
  1. 计算与上一次请求间隔下，流出多少请求。也就是本次请求与上次请求之间，是否桶满了(时间单位ms)
     - （(当前时间-上次请求时间)/1000）* 流速 = 时间间隔内允许流入的请求数量
  2. 更新本次请求时间
  3. 判断加入本次请求后，桶是否满容量，容量未满则放出请求；否则拒绝请求。


```java
public class LeakyBucket {
    public long timeStamp = System.currentTimeMillis(); // 当前时间
    public long capacity; // 桶的容量
    public long rate; // 水漏出的速度(每秒系统能处理的请求数)
    public long water; // 当前水量(当前累积请求数)


    public boolean limit() {
        long now = System.currentTimeMillis();
        water = Math.max(0, water - ((now - timeStamp)/1000) * rate); // 先执行漏水，计算剩余水量
        timeStamp = now;
        if ((water + 1) < capacity) {
            // 尝试加水,并且水还未满
            water += 1;
            return true;
        } else {
            // 水满，拒绝加水
            return false;
        }
    }
}
```

## 限流算法对比

### 计数器 vs 滑动时间窗口
- 计数器算法简单、滑动时间窗口相对复杂
- 计数器算法会存在临界问题
- 滑动窗口的时间间隔划分越细，占用空间越大
### 漏桶 vs 令牌桶
- 漏桶流速恒定
- 令牌桶允许流量突发
