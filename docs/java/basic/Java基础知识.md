---
title: Java基础知识
prev:
  text: 思考-贫血模型还是充血模型
  link: /java/basic/思考-贫血模型还是充血模型.md
next:
  text: Java中的String
  link: /java/basic/Java中的String.md
---
::: info
Java的一些基础知识总结
:::
<Toc />

---
## 访问权限
|访问权限|本类|本包的类|子类|非子类的外包类|
|:----|:----|:----|:----|:----|
|public|是|是|是|是|
|protected|是|是|是|否|
|default|是|是|否|否|
|private|是|否|否|否|

- protected这个访问权限就是为了继承设计的，它能被子类访问，但是不能被非子类的外包的类访问。

## 包装类型
&#8195;&#8195;如果想把一个基本类型视为引用类型，我们就需要用到包装类型。很多时候基本类型我们是没有办法直接使用的，下面是我总结的一些无法直接使用基本类型的情况：

- 集合不允许存放基本类型，比如List的add(Object o)。
- 需要有null值的存在(如区别非法数据)。比如int是不存在null的，初始化时0。

&#8195;&#8195;下面是8个基本类型对应的包装类型：
|基本类型|包装类型|
|:----|:----|
|boolean|Boolean|
|byte|Byte|
|short|Short|
|int|Integer|
|long|Long|
|float|Float|
|double|Double|
|char|Character|

### 自动装箱和自动拆箱
&#8195;&#8195;包装类型有一个重要的特性：自动装箱和自动拆箱。即基本类型和包装类之间的赋值可以由JVM自动完成，不需要我们手动设置：
```java 
Integer x = 1;  //自动装箱
int y = x;  //自动拆箱
```
### 不可变性和缓存池
&#8195;&#8195;通过源码我们可以知道，所有的包装类的是不可变的，也就是被final修饰的。因此一旦创建了对象，其数值就是不可变的了。同样由于其实引用类型，比较时需要使用equals()进行比较，而不是==。

&#8195;&#8195;由于其不可变性引出了两种创建包装类的方法。我们都知道，部分基本类型的数据会存在于缓存池中，因此选择从缓存池中取出数值的创建方法要优于创建新对象的方法，如果缓存池中存在数据，则直接使用缓存池中的数据：
```java 
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```
::: note
以下的基本类型存在于缓存池中：
boolean：true 和 false，
byte：所有，
short： -128~127
int：-128~127
char：\u0000 ~ \u007F
:::

## 关键字
### final
&#8195;&#8195;用于声明不可变的类、方法或者属性。
- 当声明数据时：
  - 基本类型的数值不变
  - 引用类型的引用不变
- 当声明方法时：
  - 方法不能被子类重写，private其实就是隐式得声明为final。
- 当声明类时：
  - 类不能被继承，如String。

### static
&#8195;&#8195;static用于声明静态的变量、方法或者类。
- 当变量是静态时：
  - 变量属于类，不依赖于实例，可以直接通过类访问，如A.b。静态变量在内存中只存有一份。
- 当方法是静态的时：
  - 类加载时静态方法就被加载了，不依赖于任何实例对象，可以直接通过类访问。
  - 静态方法只能访问静态变量、静态代码块和静态方法，不能使用this、super
- 静态代码块：
  - 仅在类的初始化时运行一次。
- 静态内部类：
  - 静态内部类不需要依赖于外部类的实例对象，可以直接new。
  - 静态内部类不能访问外部类非静态的属性、方法等。

## 初始化顺序
1. 父类：静态代码块、静态变量
2. 子类：静态代码块、静态变量
3. 父类：实例变量、实例代码块
4. 父类：构造函数
5. 子类：实例变量、实例代码块
6. 子类：构造函数

## 相等的判断
&#8195;&#8195;说到比较和判断，首先要注意equals()方法和==的区别：
- ==是判断值是否相等，基本类型只能使用==进行判别。
- equals()是判断引用，引用类型只能使用equals()判断。

&#8195;&#8195;第二点需要说明的就是equals()与hashCode()的配合使用。hashCode()返回的是散列值，而equals()返回的是两个引用是否相同。

&#8195;&#8195;等价的两个对象，散列值一定是相同的，但是散列值相同的两个对象的引用不一定相同。因此覆盖equals()的同时，也总应该覆盖hashCode()。

***
参考
- [深入解析java四种访问权限](https://www.cnblogs.com/java-chen-hao/p/10399947.html)
- [包装类型](https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400)
- Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.