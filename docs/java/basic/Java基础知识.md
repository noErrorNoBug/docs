---
title: Java基础知识
prev:
  text: 思考-贫血模型还是充血模型
  link: /java/basic/思考-贫血模型还是充血模型.md
next:
  text: Java中的String
  link: /java/basic/Java中的String.md
---
::: info
Java的一些基础知识总结
:::
[[toc]]

***
## 访问权限
|访问权限|本类|本包的类|子类|非子类的外包类|
|:----|:----|:----|:----|:----|
|public|是|是|是|是|
|protected|是|是|是|否|
|default|是|是|否|否|
|private|是|否|否|否|

- protected这个访问权限就是为了继承设计的，它能被子类访问，但是不能被非子类的外包的类访问。

## 包装类型
&#8195;&#8195;如果想把一个基本类型视为引用类型，我们就需要用到包装类型。很多时候基本类型我们是没有办法直接使用的，下面是我总结的一些无法直接使用基本类型的情况：

- 集合不允许存放基本类型，比如List的add(Object o)。
- 需要有null值的存在(如区别非法数据)。比如int是不存在null的，初始化时0。

&#8195;&#8195;下面是8个基本类型对应的包装类型：
|基本类型|包装类型|
|:----|:----|
|boolean|Boolean|
|byte|Byte|
|short|Short|
|int|Integer|
|long|Long|
|float|Float|
|double|Double|
|char|Character|

### 自动装箱和自动拆箱
&#8195;&#8195;包装类型有一个重要的特性：自动装箱和自动拆箱。即基本类型和包装类之间的赋值可以由JVM自动完成，不需要我们手动设置：
```java 
Integer x = 1;  //自动装箱
int y = x;  //自动拆箱
```
### 不可变性和缓存池
&#8195;&#8195;通过源码我们可以知道，所有的包装类的是不可变的，也就是被final修饰的。因此一旦创建了对象，其数值就是不可变的了。同样由于其实引用类型，比较时需要使用equals()进行比较，而不是==。

&#8195;&#8195;由于其不可变性引出了两种创建包装类的方法。我们都知道，部分基本类型的数据会存在于缓存池中，因此选择从缓存池中取出数值的创建方法要优于创建新对象的方法，如果缓存池中存在数据，则直接使用缓存池中的数据：
```java 
Integer x = new Integer(123);
Integer y = new Integer(123);
System.out.println(x == y);    // false
Integer z = Integer.valueOf(123);
Integer k = Integer.valueOf(123);
System.out.println(z == k);   // true
```
::: note
以下的基本类型存在于缓存池中：
boolean：true 和 false，
byte：所有，
short： -128~127
int：-128~127
char：\u0000 ~ \u007F
:::

## 数值计算
- Double会造成数值精度缺失，不要应用于计算。
- 使用BigDecimal进行浮点计算，并且**使用字符串进行初始化**。
- 浮点数字符串格式化也使用BigDecimal进行。
- 数值比较使用BigDecimal的compareTo()。
- 对于金融计算，一定使用BigDecimal、BigInteger避免精度和溢出问题，最好是使用比较成熟的开源金融数值计算工具包。


## 关键字
### final
&#8195;&#8195;用于声明不可变的类、方法或者属性。
- 当声明数据时：
  - 基本类型的数值不变
  - 引用类型的引用不变
- 当声明方法时：
  - 方法不能被子类重写，private其实就是隐式得声明为final。
- 当声明类时：
  - 类不能被继承，如String。

### static
&#8195;&#8195;static用于声明静态的变量、方法或者类。
- 当变量是静态时：
  - 变量属于类，不依赖于实例，可以直接通过类访问，如A.b。静态变量在内存中只存有一份。
- 当方法是静态的时：
  - 类加载时静态方法就被加载了，不依赖于任何实例对象，可以直接通过类访问。
  - 静态方法只能访问静态变量、静态代码块和静态方法，不能使用this、super
- 静态代码块：
  - 仅在类的初始化时运行一次。
- 静态内部类：
  - 静态内部类不需要依赖于外部类的实例对象，可以直接new。
  - 静态内部类不能访问外部类非静态的属性、方法等。

### 初始化顺序
1. 父类：静态代码块、静态变量
2. 子类：静态代码块、静态变量
3. 父类：实例变量、实例代码块
4. 父类：构造函数
5. 子类：实例变量、实例代码块
6. 子类：构造函数


### final、finally、finalize
&#8195;&#8195;final的特点如上所述。finally是try-catch-finally中保证代码一定被执行的机制。finalize()是java.lang.Object的一个方法，是为了保证一个对象在垃圾回收前完成特定的资源回收，并且在Java9中被标记为了deprecated（所以一般没什么特别的需求别用它回收资源），finalize还会掩盖资源回收时的出错信息，可以使用引用机制替代。


## 相等的判断
&#8195;&#8195;说到比较和判断，首先要注意equals()方法和==的区别：
- = =是判断值是否相等，基本类型只能使用= =进行判别。
- equals()是判断引用，引用类型只能使用equals()判断。

&#8195;&#8195;第二点需要说明的就是equals()与hashCode()的配合使用。hashCode()返回的是散列值，而equals()返回的是两个引用是否相同。

&#8195;&#8195;等价的两个对象，散列值一定是相同的，但是散列值相同的两个对象的引用不一定相同。因此覆盖equals()的同时，也总应该覆盖hashCode()。

&#8195;&#8195;最后一点需要注意的是，如果两个类是不同的类加载器加载的，比如有的情况是先加载了一个类，后通过热加载（不同的类加载器）加载的话，equals()进行判断也会出现为false的情况。

## 强引用、软引用、弱引用、虚引用
&#8195;&#8195;**不同的引用类型，主要提现对象不同的可达性状态和垃圾回收的影响**。

&#8195;&#8195;强引用是我们最常见的引用类型，就是我们平常声明的对象的引用，只要引用还指向一个对象，那么垃圾回收器就不会回收这种对象。

&#8195;&#8195;软引用是相对强引用弱一点的引用类型，使用SoftReference声明，当JVM内存不足时，会试图回收。

&#8195;&#8195;弱引用不能使对象豁免垃圾回收，只是提供一种关联性较弱的指向状态。

&#8195;&#8195;虚引用不能直接提供对象访问，仅仅确保对象被finalize后去做某些事情的机制。

***
参考
- [深入解析java四种访问权限](https://www.cnblogs.com/java-chen-hao/p/10399947.html)
- [包装类型](https://www.liaoxuefeng.com/wiki/1252599548343744/1260473794166400)
- Bloch J. Effective java[M]. Addison-Wesley Professional, 2017.