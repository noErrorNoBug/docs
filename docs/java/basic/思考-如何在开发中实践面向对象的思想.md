---
title: 思考-如何在开发中实践面向对象的思想
prev:
  text: 面向对象编程
  link: /java/basic/面向对象编程.md
next:
  text: 思考-贫血模型还是充血模型
  link: /java/basic/思考-贫血模型还是充血模型.md
---
::: info
语言是可以具备面向对象特征的，但是编写的程序不一定。那么应该怎么在实际编码和设计时实践面向对象的思想呢？
:::
[[toc]]

***
## 实际开发中该如何避免面向过程
&#8195;&#8195;在[面向对象编程](../basic/面向对象编程.md)中，已经阐述了面向编程的四个特点。那么区分是否是面向对象编程就可以根据这四个特点来判别。
### 避免滥用Getter、Setter破坏封装
&#8195;&#8195;在我们实际开发中，尤其是MVC模式下，当需要开发实体类(如Entity、POJO等)时，很多的同事在定义完属性后，直接使用IDE或者Lombok自动生成所有的Getter、Setter。

&#8195;&#8195;这种破坏封装的行为直接编程了面向过程编程。那么这种行为应该如何处理呢？

&#8195;&#8195;第一，**不要滥用Setter，应当尽量将业务归类使用[充血模型](../basic/思考-贫血模型还是充血模型.md)**，暴露业务类型的方法而不是直接赋值。如下所示，假设实体类是一个购物车的实体类，对于清空购物车的业务，我们不应该在Service中挨个属性Setter为null，而是在实体中定义清空购物车的方法，在Service中使用这个方法清空。
```java 
ShopCar car = new ShopCar();
// ...省略
car.getItems().clear(); // 清空购物车
```
&#8195;&#8195;第二，**Getter返回的值应该是不可被修改的，避免错误的传导**。尤其是对于引用类型，Getter提供的方法应该是Collections.unmodifiableList()这样不可修改的或者使用copy()方法。

&#8195;&#8195;第三，**复杂的业务或者耦合严重的关系，使用合理的设计模式**。设计模式本文中不再赘述，需要了解详见[设计模式范式](todo)。


### 避免滥用全局变量和全局方法
&#8195;&#8195;滥用全局变量和全局方法在我们实际开发中也屡见不鲜，其中最常见的案例就是全局的Constants类。一个服务中的所有静态变量、常量全部放在一个大而全的类中。另一个就是各种的静态Utils方法，静态方法将方法与数据分离，极大的破坏封装。

&#8195;&#8195;对于大而全的常量类，首先会降低代码的可维护性，很容易出现不同的工程师修改同一份常量类，把常量字段修改没的情况；其次，编译速度很慢，这也是优化项目启动速度的一个重要的点；最后就是代码复用性很低，每个类引用都要引用一整个常量类。

&#8195;&#8195;对于这个问题，**推荐不同业务的常量放在其业务类中**。这样设计提高了内聚也降低了耦合，而且别的业务需要引用时，可读性高，一眼就能看到相关业务范围。

&#8195;&#8195;对于Utils类，我们使用的场景是对于某些跟业务关系不大，被很多类都复用的类，我们抽取为Utils。所以**对于Utils的态度，我们只是保证不滥用即可**，并不需要像Constants一样加以代码规范的要求。因此多使用开源工具包是个很好的选择。

### 定义方法和定义数据分离
&#8195;&#8195;定义方法和定义数据分离的典型案例就是MVC下的贫血模型，这也是我们极其常见的一种Web开发模式。它的使用有很多历史性因素和其独有的优势，我们在[思考-贫血模型还是充血模型](../basic/思考-贫血模型还是充血模型.md)中进行分析。

## 实际开发如何多用面向对象
### 区分抽象类和接口的应用场景
&#8195;&#8195;抽象类和接口的定义不再赘述了，我们直接来看一下抽象类和接口的特点对比：

|接口|抽象类|
|:----|:----|
|只能被实现|只能被继承，不能被实例化|
|不能包含属性和方法实现|可以包含属性和方法实现|
|实现类必须实现接口声明的方法|子类继承抽象类，必须实现抽象方法|

&#8195;&#8195;通过上面的对比我们可以发现，**抽象类**由于有继承的特性，是为了**解决代码复用性的问题**，也由于其具有抽象方法，因此可以**同时具备多态的特性**。
&#8195;&#8195;**接口的更侧重于解耦合**，相当于一组协议或者契约，是一种抽象的广泛应用。

### 基于接口编程而非基于实现
::: note
这里我指的接口并不仅仅是Java中的接口类Interface，指的是广泛的接口定义，如接口类、抽象类、模块抽象的接口等。
:::

&#8195;&#8195;基于接口编程而非实现编程这个原则在我们程序设计和编码中非常常用也非常好用，能有效提高代码质量。之所以这么说，是因为**这个原则的核心问题就是实现接口和实现的分离，封装不稳定的实现，暴露稳定的接口**。**越抽象、越顶层、越脱离某一个具体实现的设计，越能够提升代码的灵活性，也能有效的应对需求的变化，从而实现扩展。**

&#8195;&#8195;这个原则的应用，在实际开发中可以归纳为以下几点经验，也可以作为开发中的开发规范或者统一的开发规则使用：
- **函数命名尽量只包含功能，不包含实现细节的定语**。具体的例子可以参考[面向对象编程](../basic/面向对象编程.md)中抽象一节的例子。
- **封装具体的实现细节**。在业务允许的情况下，尽可能的将功能实现的相关信息全部隐藏，比如支付接口，我们提供给用户的仅仅是一个确认支付的按钮，具体后面的所有实现（包括页面跳转、调用后台、后台的实现）等流程并不需要告知用户。
- **为实现类定义抽象的接口，所有相同功能的实现类都应该依赖功能接口的定义**。这个很好理解，设计过程应该是由顶向下的，而不是依赖于某个具体的实现去完成其他的实现。

&#8195;&#8195;写到这里就让我想到了一个开发中常见的场景，在典型的MVC模式中，业务系统的的开发通常在Service层根据业务的不同定义不同的Service接口和ServiceImpl实现，每个业务一一对应。对于这种情况我们该如何取舍？

&#8195;&#8195;我们前面说过，**这条设计原则的初衷，是为了实现接口和实现的分离，上游系统面向接口而不是实现。其最主要的场景就是下游系统（被调用方）发生变动时，上游系统不需要改变或者只需要做出很微小的改变，以此来 ==降低耦合性== 。**

&#8195;&#8195;因此，如果一个功能的实现非常的稳定，而且长期有且只有这一种实现方式，这种情况下就不应该滥用接口，直接使用实现就可以了。越不稳定或者越复杂的系统，后期扩展和维护的任务越重，才应该在抽象设计上下功夫。稳定的系统，开发完成后很少改动，就应该避免过度设计。

### 多用组合少用继承
&#8195;&#8195;在介绍面向对象编程的文章我提到过，不建议使用超过2层以上的继承关系，因为过于复杂的继承层次会很影响代码的可维护性，尤其是在业务系统的开发中，由于开发人员变动频繁，复杂系统的可维护性会指数下降（其复杂性可以参照树这种数据结构的形式）。而且继承实际上会破坏封装，子类可以获得父类的属性和方法，父类如果进行修改，那么必然影响到子类的逻辑，如果在频繁交替开发人员的项目组里简直就是个灾难。

&#8195;&#8195;对于继承产生的问题，可以使用组合、接口、委托等方式进行替代，这也是大家所认可的比较高效的编码方式。对于继承和组合的选择方式上，一般是有这样的共识：
- 如果类和类之间的继承关系很稳定，而且继承层次比较浅，那么放心大胆的使用继承就可以。
- 对于复杂系统或者继承关系复杂的类，就要慎重考虑继承了，应该尽量使用组合替代继承。
- 尽量多使用设计模式来实现组合和继承的关系。比如[装饰者模式](todo)、[策略模式](todo)、[组合模式](todo)都是[组合关系](todo)的实现，模板模式则是继承模式的实现。这些设计模式在实际开发中，不管是我们所用到的框架源码还是自己的业务系统中，都有着广泛的应用和不错的效果。

## 面向过程的一定是不好的吗？
&#8195;&#8195;在态度上，对于开发脚本类程序、算法为主的程序，我们还是以面向过程的方式进行开发，这是由其特性决定的，它们对于数据的依赖程度远低于后端业务系统。不管我们使用哪种风格开发代码，最终目的都是为了易维护、易复用、易扩展、高可读的目的，因此不用死板的追求某种开发方式。
