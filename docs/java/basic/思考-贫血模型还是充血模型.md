---
title: 思考-贫血模型还是充血模型
prev:
  text: 思考-如何在开发中实践面向对象的思想
  link: /java/basic/思考-如何在开发中实践面向对象的思想.md
next:
  text: Java基础知识
  link: /java/basic/Java基础知识.md
---
::: info
我们大部分MVC情景下使用的POJO(持久化对象)、DAO(数据访问对象)、ENTITY(实体独享)、BO(业务对象)、DTO(数据传输对象)真的定义对了吗？
:::
[[toc]]

***
## 充血模型和贫血模型
&#8195;&#8195;在Web开发中，我们都很熟悉MVC三层架构，即Model、View、Controller。前后端分离后，我们一般将后端项目分层为Repository层（数据访问层）、Service层（业务逻辑层）和Controller层（暴露接口）。在这种结构下，我们的数据访问层一般是由Entity和Repo(Mapper)组成数据访问层，由BO和Service组成业务层，由DTO或者VO和Controller组成控制层。

&#8195;&#8195;贫血模型最广泛的应用就是在上述的模式下，我们在定义Entity、BO、DTO、VO等实体时，将其定义成一个纯粹的数据结构，仅仅包含数据。而在定义业务层Service时只包含业务逻辑。加之一般会通过Lombok或者Generator直接生成所有数据结构的Getter和Setter，就使得贫血模型成为了一种面向过程的编程风格。

&#8195;&#8195;根据领域驱动设计(DDD)的方法论我们知道，它主要是应用于业务系统解耦合、业务模块划分、定义业务模块的领域模型以及领域之间的交互的。在DDD的指导下，充血模型得到了广泛的应用。充血模型则与贫血模型正好相反，是将Service层和Entity进行更小粒度的划分，将数据和业务逻辑根据业务模型的划分，归纳到同一个类或者模块中。
```java 
public class Bonus {

    private String name;
    private int bonus;

    public boolean addBonus(int activities) {
        this.bonus += activities;
        return true;
    }
}
```

&#8195;&#8195;上面这个例子就是一个充血模型的类，添加积分的业务逻辑和数据都是封装在积分的类中，不同业务之间有这明确的划分和封装。

::: tip
&#8195;&#8195;领域设计主要是由于微服务的兴起的，在微服务设计中，很重要的一项前期工作就是根据业务进行服务拆分。而领域设计正好能对服务拆分起到一定的指导作用。

&#8195;&#8195;其实领域驱动设计很大程度上并不取决于技术人员对某一项技术的掌握深度，而**非常取决于架构人员对于业务的熟悉程度和设计经验**，因此对于领域驱动设计的概念搞得再怎么清楚，不熟悉业务，该拆不出来还是拆不出来（血泪教训被坑惨了，谨慎ppt党），个人认为在微服务拆分和领域划分时，产品人员介入是很有必要的。
:::
## 转型充血模型我们应该考虑些什么
&#8195;&#8195;首先明确的一点，贫血模型也并不是不好，其便利性显而易见。因此对于转型充血模型，一般是在复杂系统的开发中进行的，比如我接触到的金融领域(还款利息等模型)、海关系统(通关税收等模型)。

&#8195;&#8195;在考虑使用贫血模型和充血模型时，我们一般需要从开发流程和代码组织两个维度进行分析。其中代码组织在前面章节已经说的很清楚了，不再赘述。至于开发流程的不同是很有必要明确的，甚至我认为**使用充血模型和贫血模型的关键，就是培养开发人员基于OOP的代码设计意识和开发流程**。

&#8195;&#8195;对于贫血模型的开发流程，之所以在复杂系统中不适用，我们很大程度上是SQL驱动或者Service驱动的。也就是开发需求时，我们确定了某个Service要做什么事儿之后，通过SQL查询出需要的数据，在Service中面向过程的将业务流程开发出来，然后返回给Controller。SQL都是针对于业务逻辑进行编写，老旧系统直接在SQL中包含复杂的业务逻辑（很多甚至直接存储过程执行业务逻辑），复用性和可维护性真的一言难尽。对于简单系统，十几个类就能解决全部业务了，那也无所谓，尤其是单体应用，赶紧开发完赶紧结束，但是对于复杂系统这种开发形式真就太头疼了。

&#8195;&#8195;在充血模型的开发流程下我们**首先需要考虑的就是梳理清楚所有的业务，定义不同业务领域下的属性和方法**。领域模型相当于可以复用的业务逻辑层，新的功能的开发和追加，都是基于事先定义好的领域模型完成的。因此**事先的业务梳理和设计文档就非常的重要**。

&#8195;&#8195;这一块儿的内容比较抽象，我基于我的一个简单的对公支付系统进行简单的说明（举例中为了方便理解，进行了简化）。

&#8195;&#8195;在这个系统中，功能主要分为三方签解约、不同种类协议扣费、交易状态监控、核注和补核注、冲正业务这五个业务。在这五个业务中，我们可以划分为这么几个领域模型：协议领域、订单领域、账单领域。其中协议领域涉及到的业务包括签约、解约；账单领域涉及到的业务包含不同协议的扣费、交易状态监控、冲正业务；订单领域涉及到的业务包括核注和补核注、冲正业务。

&#8195;&#8195;根据上面的分析，我们对各个领域模型的功能做出设计。对于协议领域，包括签约、解约两个主要的功能，在代码层面这就是我们需要提供的方法，由于签约解约其实是一个字段控制，因此只需要提供一个方法即可；其次需要明确协议相关的数据结构，到代码层面也就是协议类中需要用到的属性有哪些。在账单领域，包括扣费、对账两个个主要功能，在代码层面也就是至少要提供扣费和对账两个方法；数据结构方面，需要定义方法所需要的属性。在订单领域，需要提供核注方法、对账方法两个方法，并且定义所需要的属性。

&#8195;&#8195;领域定义完成后，那么对于系统中五个业务的接口的开发，就变成了在Service层对不同领域业务先后顺序的一个调用和组织了。那么Service层就只负责不同接口的流程控制和对数据层的查询了。那么以后我们需要对系统增加业务时，只需要对定义的相关领域进行复用即可。下面是一个与银行接口对接的缴款的简易的示意图：

![充血模型](/images/java/basic/充血模型.jpeg)
