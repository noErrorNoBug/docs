---
title: 基于可靠消息的最终一致性方案
prev:
  text: TCC事务补偿方案
  link: /methodology/transaction/TCC事务补偿方案.md
next:
  text: 最大努力通知型事务方案
  link: /methodology/transaction/最大努力通知型事务方案.md
---
::: info
&#8195;&#8195;如名所说，这种方案基于可靠的消息投递，是一种最终一致性事务的解决方案，目前市面上有很多可靠消息投递的中间件都可以实现。
:::
[[toc]]

***

## 原理
&#8195;&#8195;基于可靠性消息的**最终一致性事务方案主要依靠消息中间件如Kafka、RocketMQ、RabbitMQ等的可靠性机制来实现数据的一致性投递**。

&#8195;&#8195;以电商的支付场景来说，用户订单支付后不需要同步等待支付结果的，可以继续做其他的事情。但是对于大多数的系统来说，大部分是在发起支付之后，等待第三方支付平台提供支付结果的异步通知。大部分电商会基于支付结果给账户增加积分等一系列的操作。因此在接到第三方支付渠道的支付结果通知后，需要更新支付服务的状态、以及更新账户积分余额、发放优惠券等一系列的操作，并且要求数据的最终一致性。

![基于可靠消息投递的最终一致性模型](/images/methodology/基于可靠消息投递的最终一致性模型.png)


基于可靠消息的最终一致性方案中，其**核心是利用消息中间件的可靠消息的投递，将本地事务和消息投递两个动作作为原子的，实现最终一致性**。这个原子性问题有两个后果：

* 先发送消息，再执行本地事务：这种情况容易出现消息发送成功但是本地事务执行失败的情况，倒是数据仍然不一致：
```java
begin transaction;
sendMsg();
updateStatus();
commit transaction;
```
* 先执行本地事务，再发送消息：这种情况会产生MQ由于网络响应超时，本地事务回滚但是MQ实际已经发送消息导致数据不一致问题。
```java
begin transaction;
updateStatus();
sendMsg();
commit transaction;
```

## RocketMQ的事务消息模型
关于以上的问题，也有很多解决方式，以RocketMQ为例，提供了事务消息模型，具体执行过程如下：

![RocketMQ事务消息模型](/images/methodology/RocketMQ事务消息模型.png)

1. 生产者发送一个事务消息到MQ，MQ存储这个消息但是不让消费者发现。
2. 生产者执行具体的逻辑，完成本地事务。
3. 生产者根据本地事务的执行情况发送一条确认消息给MQ，如果成功发送一个Commit消息，表示第一步中的消息可以消费；否则发送一个Rollback消息，将MQ中的消息删除。
4. 如果本地事务执行中因为一些原因，MQ没有收到Confirm消息，那么MQ会定时回查获取本地消息的执行结果，然后根据回查结果决定是否将消息投递给消费者。
5. MQ上的消息被生产者确认后，消费者就可以消费本条消息，消费后返回一个签收确认给MQ，表示投递成功。
不难发现，**这套事务模型是由生产者决定的，如果消费者一直没有签收消息，那么MQ将会一直投递，完成最终一致性**。RocketMQ的事务模型中**最最核心的应该是事务会查机制**。在分布式系统中，有很多因为网络原因等产生的中间状态，服务提供者可以提供一个接口用于回查操作状态。

