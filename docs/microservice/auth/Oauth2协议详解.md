---
title: Oauth2协议详解
prev:
  text: SpringSecurity核心原理
  link: /microservice/auth/SpringSecurity核心原理.md
next:
  text: SpringSecurityOauth2核心原理
  link: /microservice/auth/SpringSecurityOauth2核心原理.md
---
::: info 综述
&#8195;&#8195;OAuth2(Open Authenritation)是一个授权的开放网络标准，允许用户授权第三方应用提供他们存储在其他服务提供者上的信息，而不需要将用户名和密码提供给第三方应用或分享他们数据的所有内容。Oauth2协议：https://datatracker.ietf.org/doc/html/rfc6749

&#8195;&#8195;OAuth2是一个协议，具有以下特点：
- 简单：不管是服务提供者还是应用开发者，都易于理解和使用。
- 安全：没有涉及到用户秘钥等信息，更加安全。
- 开放：任何服务提供商都可以实现Oauth，任何软件开发商都可以使用Oauth。
:::
[[toc]]
***

## 介绍
### 应用场景
- 原生app授权：app登录后的所有请求接口，为了安全认证，都带有token信息。
- 前后端分离页面：前端请求后台数据，进行Oauth2认证。
- 第三方登录授权：如微信、支付宝、微博等等。

### 名词解释
- Third­party application：第三方应用程序，又称“客户端(client)”
- HTTP service：Http服务提供商
- Resource Owner：资源拥有者，又称“用户”
- User Agent：用户代理，比如浏览器
- Authorization server：授权服务器，服务提供商专门处理认证授权的服务器
- Resource server：资源服务器，服务提供商存放用户生成资源的服务器，它与授权服务器，可以是一台，也可以不是同一台。

### 优缺点
优点：
- 安全性更强：客户端不需要接触用户名密码，服务端更容易集中保护
- 广泛传播和使用
- 短寿命和封装的token
- 资源服务器和授权服务器解耦合
- 集中式授权，简化客户端
- HTTP/JSON友好，易于请求和传递token
- 考虑多种客户端架构场景
- 客户可以具有多种信任级别

缺点：
- 协议框架宽泛，实现上兼容性和操作性差
- 不是一个认证协议，本身不能告诉用户任何信息

### 设计思路
&#8195;&#8195;OAuth在"客户端"与"服务提供商"之间，设置了一个授权层(authorization layer)。"客户端"不能直接登 录"服务提供商"，只能登录授权层，以此将用户与客户端区分开来。"客户端"登录授权层所用的令牌 (token)，与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期，"客户端"登 录授权层以后，"服务提供商"根据令牌的权限范围和有效期，向"客户端"开放用户储存的资料。
OAuth 2.0的运行流程如下图，摘自RFC 6749：

![oauth2流程](/images/microservice/auth/oauth2流程.png)

1. 用户打开客户端后，客户端要求客户给与授权。
2. 用户同意给予客户端授权。
3. 客户端使用上一步的授权，向授权服务器申请令牌。
4. 授权服务器对客户端进行认证后，同意颁发令牌。
5. 客户端使用令牌，向资源服务器申请获取资源。
6. 资源服务器确认令牌无误，同意向客户端开放资源。

::: note
令牌(token)与密码(password)的作用是一样的，都可以进入系统，但是有三点差异。
- 令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。
- 令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。
- 令牌有权限范围(scope)。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。
:::

## 客户端授权模式
&#8195;&#8195;OAuth 2.0 对于如何颁发令牌的细节，规定得非常详细。具体来说，一共分成四种授权类型(authorization grant)，即五种颁发令牌的方式，适用于不同的互联网场景。
- 授权码模式(authorization code)
- 密码模式(resource owner password credentials)
- 简化(隐式)模式(implicit)
- 客户端模式(client credentials)
- 刷新授权(refresh token)


&#8195;&#8195;**不管哪一种授权方式，第三方应用申请令牌之前，都必须先到系统备案，说明自己的身份，然后会拿到两个身份识别码:客户端 ID(client ID)和客户端密钥(client secret)**。

### 授权码模式
&#8195;&#8195;**授权码模式指的是第三方应用首先申请一个授权码，然后再用该授权码获取令牌。这种方式最常用，适用于有后端服务的Web应用**。授权码通过前端传送，令牌则是存储在后端，而且所有与资源服务器的交互都是由后端完成，可以避免令牌泄漏。

![授权码模式](/images/microservice/auth/授权码模式.png)

::: tip 授权码模式流程
1. 用户访问客户端，客户端将用户导向授权服务器
2. 用户选择是否给客户端授权
3. 假设用户给客户端授权，授权服务器将用户导向客户端事先指定的“重定向URI”，同时携带一个授权码。
4. 客户端接收到授权码，附上早先指定的“重定向URI”和授权码，向授权服务器申请令牌。这一步是客户端后台完成，对用户不可见。
5. 授权服务器核对授权码和重定向URI，确认无误后，向客户端发送访问令牌(access token)和更新令牌(refresh token)。
:::

&#8195;&#8195;下面通过一个例子来说明授权码模式(方便解释使用支付宝和淘宝举例，但并不是支付宝的真正授权流程)：
#### 第一步：导向授权服务器申请授权
&#8195;&#8195;淘宝作为客户端，用户想要购物结算，点击结算(即访问客户端某个资源)，淘宝会跳转至支付宝授权界面，去授权用户数据给淘宝，下面示意一个链接：
```lua
>https://b.com/oauth/authorize?response_type=code&client_id=CLIENT_ID&redirect_uri=CALLBACK_URL&scope=pay
```
&#8195;&#8195;这个请求就是示意淘宝跳转支付宝的请求，其中有几个参数：
- response_type：携带授权类型，必选项，值code要求返回授权码
- client_id：可选项，让授权服务器知道谁在请求，需要给谁授权，此处CLIENT_ID应为淘宝的标识
- redirect_uri：可选项，重定向URI，即支付宝授权后，需要跳转回去的URI
- scope：可选项，需要授权的范围，此处pay代指交易权限

#### 第二、三步：给客户端授权
&#8195;&#8195;此时支付宝会要求用户登录并且选择是否给淘宝授予支付权限，用户表示同意，这时支付宝会按照第一步中的redirect_uri跳转并且携带一个授权码：
```lua
# code参数就是授权码
https://a.com/callback?code=AUTHORIZATION_CODE
```

#### 第四步：客户端携带授权码申请令牌
&#8195;&#8195;淘宝拿到授权码后，在淘宝的后端，向支付宝发送一个申请令牌的请求：
```lua
https://b.com/oauth/token? 2 >client_id=CLIENT_ID&client_secret=CLIENT_SECRET&grant_type=authorization_code&code=AUTHORIZATION_CODE&redirect_uri=CALLBACK_URL
```
&#8195;&#8195;这里也需要携带几个参数：
- client_id：客户端的标识
- client_secret：客户端标识，与client_id共同确认客户端的参数，client_secret参数是保密的，只能由后端发送
- grant_type：授权类型，这里值表示采用授权码方式
- code：上一步的授权码
- redirect_uri：令牌办法后的重定向URI

&#8195;&#8195;**这一步有两个关键的点，一个是需要携带颁发的授权码，另一个是如果要认证授权码，需要同时通过保密的client_secret认证客户端标识，因为仅仅有授权码也是可能被劫持的**。

#### 第五步：授权服务器颁发令牌
&#8195;&#8195;支付宝收到淘宝发来的申请令牌的请求，验证通过后就会颁发令牌，具体做法是请求上一步的redirect_uri地址发送一段JSON：
```json
{
  "access_token":"ACCESS_TOKEN",
  "token_type":"bearer",
  "expires_in":2592000,
  "refresh_token":"REFRESH_TOKEN",
  "scope":"pay",
  "uid":100101,
  "info":{...}
}
```
&#8195;&#8195;这便是令牌信息，淘宝可以持有令牌信息进行资源访问，其中access_token字段就是令牌。

### 简化模式
&#8195;&#8195;有些应用是纯前端应用，没有后台服务，那么此时授权码模式就无法使用，因此需要简化模式进行授权。这个模式**没有授权码这个中间步骤**，直接通过浏览器或者移动端向授权服务器申请令牌。**这种方式直接将令牌传给前端，是很不安全的，只能用于一些安全程度不高的场景，而且令牌的有效期要很短，一般只要求会话期间，浏览器关掉就失效了**。

![简化模式](/images/microservice/auth/简化模式.png)

::: tip 简化模式流程
1. 用户访问客户端，客户端将用户导向授权服务器
2. 用户选择是否给客户端授权
3. 假设用户给客户端授权，授权服务器将用户导向客户端事先指定的“重定向URI”，并在URI的Hash部分包含了访问令牌。
4. 客户端向资源服务器发出请求，不携带上一步的Hash值。
5. 资源服务器返回一个网页，其中包含的代码可以获取到Hash中的令牌。
6. 客户端执行脚本，提取令牌，并将令牌发送给资源服务器。
:::

### 密码模式
&#8195;&#8195;**如果高度信任某个应用，RFC6749也是允许把用户名和密码直接告诉应用，这样就使用密码申请令牌，这就是密码模式**。

&#8195;&#8195;这种模式下，必须把用户名和密码传送给客户端，但是客户端不得存储密码。这通常是要求对客户端十分信任的情况下，比如客户端是操作系统的一部分、或者跟资源服务器和授权服务器是同一家公司等等。所以**使用场景一般是自家公司搭建的授权服务器**。

![用户名密码模式](/images/microservice/auth/用户名密码模式.png)

::: tip 密码模式流程
1. 用户访问客户端并提供用户名和密码
2. 客户端将用户名和密码发给授权服务器，向后者请求令牌。
3. 授权服务器确认无误后，向客户端提供访问令牌。
:::

### 客户端模式
&#8195;&#8195;客户端模式是指客户端以自己的名义，而不是用户的名义，向服务提供商进行授权。**场景是没有前端的命令行应用，即在命令行下请求令牌，一般提供给我们完全信任的服务端服务器**。

![客户端模式](/images/microservice/auth/客户端模式.png)

::: tip 客户端模式流程
1. 客户端向授权服务器进行身份认证，并要求一个访问令牌。
2. 授权服务器确认无误后，向客户端提供访问令牌。
:::

### 刷新授权
&#8195;&#8195;客户端拿到令牌后，就可以向资源服务器请求资源了。**此时每个向资源服务器发送的API请求**，都必须携带令牌。具体做法是，**在请求头中加入一个Authentication字段，令牌就放在这个字段里，或者通过access_token字段的参数进行请求**。

&#8195;&#8195;令牌如果到期后，使用上述的授权过程再次请求的话，体验非常不好，因此Oauth2允许更新令牌，具体的做法是，办法令牌时一次性办法两个令牌，即上文中提到的access_token作为请求正常使用的令牌，refresh_token作为更新令牌。令牌到期前，用户使用refresh_token发送一个请求进行令牌更新。
```lua
https://b.com/oauth/token?grant_type=refresh_token&client_id=CLIENT_ID&client_secret=CLIENT_SECRET&refresh_token=REFRESH_TOKEN # 用于更新令牌的令牌
```
- grant_type：此时携带的参数为更新令牌
- client_id：客户端标识
- client_secret：客户端标识
- refresh_token：请求令牌时的refresh_token