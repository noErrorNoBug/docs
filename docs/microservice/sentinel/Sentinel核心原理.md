---
title: Sentinel核心原理
prev:
  text: Sentinel整合RestTemplate和OpenFeign
  link: /microservice/sentinel/Sentinel整合RestTemplate和OpenFeign.md
next:
  text: Sentinel持久化原理
  link: /microservice/sentinel/Sentinel持久化原理.md
---
::: info
&#8195;&#8195;Sentinel的主要限流功能在客户端实现，包括规则校验、限流算法实现、拦截请求等等核心功能。服务端也就是DashBoard主要是配置规则和客户端交互，因此并没有与限流相关的特别的功能，因此需要格外关注客户端的实现原理。
:::
[[toc]]
***

## 客户端和服务端通信原理
&#8195;&#8195;在客户端启动时，我们在配置中会配置spring.cloud.sentinel.transport.port属性，这个属性配置一个端口在服务启动时用于跟DashBoard进行通信。Spring Cloud Alibaba Sentinel包，也就是客户端包在这个端口下设置了很多的API(比如/setRules用于接收规则设定),规则推送、实时监控等DashBoard的功能就是通过这些API实现的。

&#8195;&#8195;以上的功能被集成在了Alibaba Sentinel的包中，具体实现在sentinel-transport-simple-http中。

&#8195;&#8195;Sentinel客户端在启动时，向DashBoard进行注册，并且将自身的相关信息如ip、port等携带给DashBoard，并且保持心跳，这部分的原理类似于Nacos注册原理。

&#8195;&#8195;DashBoard中有定时器，会定时询问客户端状况或者推送给客户端用户配置的规则。

![DashBoard与Client通信原理](/images/microservice/sentinel/DashBoard与Client通信原理.png)

## @SentinelResource注解原理
&#8195;&#8195;自动装配时(通过SentinelAutoConfiguration)，会初始化名为SentinelResourceAspect的bean，我们已知@SentinelResource是通过AOP实现的了，那么这个Bean很明显就是切面的具体逻辑。

&#8195;&#8195;**SentinelResourceAspect在自动装配时初始化，在这个切面中，会拦截带有@SentinelResource注解的方法**，切面中的逻辑就类似于我们[使用API实现切面](基于Sentinel实现服务限流.md)的逻辑：
- 在方法执行前：调用SphU.entry()方法进行限流
- 执行后catch到BlockException和其他异常进行处理

&#8195;&#8195;由此我们也可以再次验证到，**SphU.entry()是Sentinel限流的核心实现也是其入口**。

## 责任链设计模式
### 责任链处理流程

&#8195;&#8195;与大多数的中间件一样，Sentinel也是使用责任链模式，将整个检验流程串联，Sentinel是在SphU.entry()方法中，创建对应资源责任链和调用其责任链实现限流功能。

&#8195;&#8195;下面是在SphU.entry()方法中执行责任链的源码：
```java
ProcessorSlot<Object> chain = lookProcessChain(resourceWrapper);
```

&#8195;&#8195;责任链的具体逻辑如下
1. 双重检测对应资源名称的chain是否为空(所有的chain存储在map中)
   - 通过SPI机制加载ProcessSlot
   - 将加载的所有ProcessSlot保存到List中
   - 将这个list保存到chain中(使用链表按顺序添加到尾部，顺序是类似Order设定的，会先解析)
2. 如果为空则初始化chain，并添加到map中，key是资源名，value是责任链chain


&#8195;&#8195;获取完责任链后，SphU.entry()就会执行责任链，按照联调挨个处理责任链中slot所负责的功能，chain接口定义了entry()方法，执行具体的逻辑。

&#8195;&#8195;通过上面的分析，我们可以得出结论：**Sentinel通过责任链模式处理限流降级的逻辑，通过一个Map保存资源名称和对应的责任链，每一个责任链由固定顺序的ProcessSlot组成，每一个Slot处理器完成不同的功能**。

### 责任链中的默认处理器
- **NodeSelectorSlot**：创建或者获取簇点链路
- **ClusterBuilderSlot**：创建或者获取集群节点
- **LogSlot**：日志处理，catch到异常记录日志
- **StatisticSlot**：统计处理器，在执行完所有链路后才执行统计逻辑
- **AuthoritySlot**：授权规则处理器，处理授权规则的逻辑
- **SystemSlot**：系统规则处理器，处理系统规则的逻辑
- **FlowSlot**：流量规则处理器，处理限流规则逻辑
- **DegradeSlot**：熔断规则处理器，处理熔断规则逻辑

![责任链](/images/microservice/sentinel/责任链.png)

## 限流核心原理
::: note
&#8195;&#8195;限流的核心逻辑由FlowSlot完成，这里面我们需要关注的问题有以下几个：
- 如何存储限流规则
- 如何校验限流规则
:::

### 规则存储
&#8195;&#8195;**流控规则的实现是FlowRule类**，在FlowSlot中，通过资源名称获取到FlowRule的集合。FlowRule中的属性即配置时需要的QPS、线程数、单机阈值、是否集群、流控模式、流控效果等等。

### 校验规则
&#8195;&#8195;通过循环上一步获取到的FlowRule集合，根据流控模式选择不同的实现，下面是直接失败模式的流程：

1. 判断阈值类型并且获取阈值：QPS阈值或者Threads阈值，对应相关的配置项
2. 通过StatisticSlot获取累计请求造成的数量，具体实现为[滑动时间窗口算法](../../algorithm/domain/限流算法.md)
3. 判断总请求数造成的数量是否大于阈值，如果大于阈值，校验不通过，抛出FlowException
   - 这里需要注意StatisticFlot会捕获异常，在try逻辑中会累加QPS或者线程数量等等。
   - 在catch中，会统计blockQPS等，然后计算滑动时间窗口等逻辑。
   - 最后再向上抛出异常，最终被Aspect捕获，调用BlockExceptionHandler处理，也就是@SentinelResource中配置的BlockHandler和处理方法。
4. 如果不大于阈值，放过请求，并且进行统计逻辑

&#8195;&#8195;**这里最主要的是理解异常处理流程，即抛出的异常首先经过StatisticFlot完成算法统计，最终在Aspect中交给BlockExceptionHandler处理**。其他模式的判断流程只是业务流程的实现而已，不在赘述。

## 熔断器核心原理
::: note
&#8195;&#8195;Sentinel中熔断器的实现比较标准，是由DegradeFlot完成具体的执行，很有参考意义，我们除了需要关注熔断规则的存储和校验，还需要关注熔断器本身的实现。
:::

### 规则校验流程
&#8195;&#8195;在DegradeFlot中，也是通过资源名称获取到断路器集合，然后校验每一个断路器的短路规则，从而控制断路器的开闭。

&#8195;&#8195;校验不通过的断路器规则，会抛出DegradeException，同样也会经过StatisticFlot完成算法统计并且在Aspect中交给BlockExceptionHandler处理。

### 熔断器结构
&#8195;&#8195;**熔断器的实现是CircuitBreaker，里面包含熔断规则，熔断规则的实体是DegradeRule**，里面包含慢调用比例、异常比例、异常数等等需要配置的多个属性。

&#8195;&#8195;**CircuitBreaker中除了存放规则，还会存放状态：OPEN(断开)，HALF_OPEN(半开)，CLOSED(闭合)**。Sentinel通过规则和状态，组成了断路器的执行流程：
1. 断路器闭合(CLOSED)，放行请求
2. 断路器断开(OPEN)，判断否超过熔断时长且状态可以更改为半开(HAFE_OPEN)，放行请求
   - 更改半开状态逻辑：CAS修改状态为半开
3. 否则，不放行请求，抛出DegradeException

&#8195;&#8195;这里我们会有一个疑问，除了这里会将OPEN转换为HAFE_OPEN，还有哪里会转换断路器状态？答案是在限流规则的算法实现中和调用链路完成后的统计中(这个也是由DegreadeFlot完成)，这里只说明断路器结构，下文会具体分析滑动时间窗口算法。

### 更改断路器状态
&#8195;&#8195;**DegradeFlot是默认责任链的最后一环，这一环执行完毕后，就会进行一些收尾和后处理的工作**，这里简单说明一下：
- 如果当前节点有BlockException，结束
- 如果没有BlockException，根据配置选择慢响应时间或者异常比例断路器实现(下面流程以慢响应策略为例)：
  - 当前的Request执行时间与配置的慢响应时间对比，统计慢响应，计算最大RT(慢响应+1)，总的调用次数+1，并且**改变断路器状态**：
  - OPEN：保持OPEN断开
  - HAFE_OPEN：如果本次响应时间超过最大RT，断开断路器(OPEN)；如果没有超过最大RT，闭合断路器(CLOSED)
  - CLOSED：统计慢调用次数、慢响应次数等指标，根据降级规则判断是否满足降级标准，如果满足更改为断开(OPEN)。

## 滑动时间窗口实现原理
&#8195;&#8195;[滑动时间窗口](../../algorithm/domain/限流算法.md)的原理详见之前写过的相关文章，要实现一个滑动时间窗口算法，我们主要需要2个步骤和一个载体：
- 载体：时间间隔计数器
- 步骤：
  1. 时间窗口滑动
  2. 请求数据统计


&#8195;&#8195;Sentinel的实现也基本基于此，下面通过这三个纬度进行说明。

### 时间窗口载体
&#8195;&#8195;Sentinel使用的是滑动窗口算法来实现的限流，**时间窗口有两个统计维度**，数据累加时，既会在秒维度累加，也会在分钟维度累加：
- **rollingCounterInSecond**：秒维度，时间窗口为1000ms，时间间隔500ms，也就是时间窗口包含2个格子，即时间窗口数组包含2个元素。
- **rollingCounterInMinute**：分钟维度，时间窗口为60s，时间间隔为1s，一个时间窗口内为60个格子，即时间窗口数组包含60个元素。
- **WindowWrapper**：时间间隔的实现载体，可以设定长度、起始时间、请求桶bucket

### 定位时间窗口
&#8195;&#8195;源码中currentWindow()方法是具体对滑动时间窗口的实现：
1. **计算请求属于当前时间窗口的哪个元素**：**(当前时间(ms) / 间隔时间) % 窗格数组大小**，如当前时间1200ms，上面已知500ms是一个格子间隔，1200/500再对数组大小取模，也就是对2取模，可知落在rollingCounterInSecond的第一个格子中。
2. **计算时间间隔的开始时间**：当前时间-当前时间%格子间隔，即计算上一步请求落在的格子的开始时间，如上即格子从1000ms开始统计
3. **判断时间间隔位置**：
   - **第一个请求**：如果时间窗口内2个元素为空，则说明是第一个请求，创建窗格WindowWrapper(长度、起始时间、空Bucket)，将事件窗格放入滑动窗口数组。
   - **本次时间窗窗口内**：如果格子开始时间相同，返回本次的间隔，如800ms和820ms返回的是同一个间隔。
   - **本次请求为下一个时间窗口**：如810ms和1600ms的两次连续请求，810ms的请求的时间窗格开始时间是500ms的，1600ms是开始时间1500ms的时间窗格，则会重置原有窗口的值，也就是窗格已经是下一个时间窗口了。
   - **时钟回拨**：请求时间小于窗口开始时间，这说明实际上出现了异常状况，创建一个新的窗口重新统计即可，发生时钟回拨那么以前的统计结果也没啥意义了，而且程序本身应该杜绝这种情况的发生，有这个分支只是为了让程序更加健壮。

&#8195;&#8195;综上，时间窗口的滑动指标就两个，满足这两个条件说明时间窗口应该向下滑动，即进入了下一个时间窗口：
- 时间窗口数组下标相同
- 当前请求时间大于时间间隔开始时间

### 数据统计逻辑
&#8195;&#8195;时间窗口滑动到正确位置后，那么就需要对请求数据进行统计，统计逻辑如下：
- 使用时间间隔内的Bucket，统计请求指标，如PASS的请求、BLOCK的请求等等，在算法中统计的是PASS指标的请求。
- Bucket中的Counter是一个LongAdder[]数组，不同的指标为数组中的不同元素，统计时即对LongAdder进行累加。
- 限流的责任链中即通过判断counter中的数进行请求是否限流。

&#8195;&#8195;通过上面的逻辑我们大概就可以看出，Sentinel计算是否限流的大概流程，如判断1s内的QPS，那么就是获取时间窗口中所有间隔counter的累加。

## 漏桶算法实现原理
&#8195;&#8195;排队等待功能的实现使用的是[漏桶算法](../../algorithm/domain/限流算法.md)，但是实现逻辑并不相同：
1. 根据配置的值计算请求之间的时间间隔，比如配置了排队等待的qps为10，那么流速也就是10，两个请求之间的时间间隔应该是100ms。
2. 计算两次请求之间的时间间隔是否在要求间隔内
3. 如果在时间间隔外：请求通过，并记录请求时间
4. 如果在时间间隔内：计算需要等待的时间(并且不超过超时时间)，wait(剩余等待时间)

&#8195;&#8195;上述的逻辑有些问题：
- 上次请求时间没有加锁，多次计算是有并发问题的。
- 只计算间隔时间，思想上是漏桶算法，但是实际实现却是计数器算法，存在临界问题，比如间隔100ms，在其中一个100ms内来了很多请求，则都会放在同一个等待间隔内，流速也是不均匀的。

## 令牌桶算法实现原理
&#8195;&#8195;预热模式(Warm Up)模式在Sentinel中使用的是[令牌桶算法](../../algorithm/domain/限流算法.md)的实现，但是增加了预热的逻辑，大致逻辑如下：

1. 根据配置会计算一个预热数据的斜率(具体数学实现很复杂)
2. 根据不同的时间点使用不同的斜率阶梯式的设置向令牌桶发放令牌的速率
3. 最终达到设置的令牌发放速率

## 拦截器处理Web请求原理
&#8195;&#8195;上述流程是按照@SentinelResource注解的流程展开的，Sentinel同样支持使用Nacos或者配置文件进行资源路径的配置，那么这时候就需要通过对Web请求进行拦截。

### 自动装配
&#8195;&#8195;拦截请求是通过SentinelWebAutoConfiguration进行自动装配的，这个自动装配类**实现了WebMvcConfigurer接口。也就是需要实现addInterceptors()方法添加拦截器**。

&#8195;&#8195;项目启动时，**会注入拦截器SentinelWebInterceptor**，上述添加拦截器的方法就是将此添加到拦截器链路中。


### 拦截器逻辑
&#8195;&#8195;SentinelWebInterceptor通过实现preHandler方法，在拦截器中，使用了SphU.entry()方法，其核心还是一样的，只是拦截方式不一样。