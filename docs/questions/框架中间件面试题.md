---
title: 框架中间件面试题
prev:
  text: Java面试题
  link: /questions/Java面试题.md
next:
  text: 分布式和微服务面试题
  link: /questions/分布式和微服务面试题.md
---
::: info
&#8195;&#8195;面试题话术汇总，方便面试复习
:::
[[toc]]

***

## Spring IOC 容器
### 什么是IOC？什么是DI？
&#8195;&#8195;IOC指的是控制反转，是一种设计思想。正常情况下，我们使用一个对象或者使用一个Bean，是由用户通过声明的方式来加载和使用的，是由用户进行控制的。SpringIOC首先是一个容器，Spring使用容器来创建和管理Bean，用户只需要通过一定的手段获取和使用Bean即可。IOC可以解决代码层级之间的耦合问题。

&#8195;&#8195;DI是指的依赖注入，是Spring对IOC容器的一种实现，@Autowire就是DI的注解方式。同时Spring支持以来查找，可以通过Spring上下文来getBean。

### 如何将一个类交给Spring管理？
1. 可以通过注解或者xml的方式声明一个Spring Bean。
2. 通过加载Spring上下文(xxxApplicationContext)将声明的Bean配置加载到Spring容器中。
3. 通过依赖注入或者依赖查找就可以获取到Bean。


### BeanDefinition是什么？
&#8195;&#8195;Bean的配置方式有很多种，需要一个统一的方式交给BeanFactory用于生产Bean。BeanDefinition就是保存Bean配置信息的接口，它会保存Bean的装配信息、字段信息等等，用于BeanFactory反射生成Bean。

### BeanDefinitionReader是什么？
&#8195;&#8195;Spring Context通过扫描配置或者扫描注解的方式来加载Bean。BeanDefinitionReader就是用于读取Bean配置。

### BeanDefinitionScanner是什么？
&#8195;&#8195;Spring Context在项目启动时读取到的Bean配置有的是有效的有的是无效的，需要通过扫描识别出需要进行加载的Bean配置，BeanDefinitionScanner就是进行扫描甄别的。

### BeanDefinitionRegistry是什么？
&#8195;&#8195;Spring Context利用BeanDefinitionRegistry，将不同的配置方式读取并封装为BeanDefinition，存入ConcurrentHashMap中，提供给BeanFactory使用。

### BeanFactory是什么？
&#8195;&#8195;BeanFactory是Spring的顶层核心接口，使用简单工厂模式生产Bean并且提供一些扩展机制，用于在bean的生命周期中调用我们的扩展来处理Bean：
- Spring容器启动阶段：主要是注册Bean，并提供扩展接口
  1. 根据BeanDefinition生产Bean，并保存到缓存中。
  2. BeanFactory定义了一个BeanFactoryPostProcessor接口允许我们扩展。
- bean实例化阶段：主要是提供扩展接口
  1. 提供各种Aware扩展接口：对于实现了Aware接口的Bean，实例化Bean时Spring会帮我们一块儿注入BeanFactory实例。
  2. 提供BeanPostProcessor接口：Spring实例化bean时会调用BeanPostProcessor接口中的方法。
  3. InitializingBean接口：Spring实例化bean时进行调用。
  4. DisposableBean接口：Spring实例化bean时进行调用。

### Spring上下文和BeanFactory有什么区别？
&#8195;&#8195;Spring上下文即ApplicationContext，它实现了BeanFactory，也就是说Spring上下文是BeanFactory的一种实现，具备BeanFactory定义BeanDefinition和生产Bean的能力。除此之外，Spring上下文包含了BeanDefinitionReader、BeanDefinitionScanner、以及上下文生命周期的各种实现，可以进行扫描、事件、国际化等等Spring容器相关的功能。

&#8195;&#8195;BeanFactory只能注册BeanDefinition和生产Bean，并不能扫描。

### 什么是FactoryBean？
&#8195;&#8195;FactoryBean是一个接口。Bean在SpringIOC容器进行实例化时，有两种方式，一种是反射，另一种是通过工厂方式。

&#8195;&#8195;FactoryBean就是实现工厂方式实例化Bean的接口。实现接口的Bean可以通过接口getObject()方法自定义Bean实例化的过程。

### Spring IOC容器的加载过程是怎样的？
1. 准备工作：注册内置的PostProcessor(用于IOC容器加载不同的功能)、注册BeanDefinitionReader、BeanDefinitionScanner、BeanDefinitionRegistry。
2. 调用BeanDefinitionPostProcessor注册BeanDefinition：
   1. BeanDefinitionReader读取项目指定范围下的配置类。
   2. BeanDefinitionScanner扫描配置类，确定出需要装配Bean的范围。
   3. BeanDefinitionRegistry将扫描到的有效的配置类注册为BeanDefinition，并保存到BeanFactory的内存(ConcurrentHashMap)中。
3. 注册Bean的后置处理器BeanPostProcessor。
4. 初始化国际化资源。
5. 创建事件多播器。
6. 刷新容器，SpringBoot启动。
7. 将事件监听器注册到事件多播器。
8. 实例化单例Bean(非抽象、单例、不是懒加载)：
   1. BeanFactory根据BeanDefinition集合，在getBean()方法中利用反射**实例化**Bean。
   2. BeanFactory将实例化后的Bean进行属性填充。(循环依赖的问题就出现在属性填充阶段)
   3.  BeanFactory对Bean进行初始化，执行init()、destory()等方法。
   4.  将初始化后的Bean存储一级缓存(单例池)中。
9.  最后刷新容器，SpringCloud启动。

### Bean的加载过程(生命周期)是怎样的？
1. Bean的实例化：Bean实例化可以有两种方法，反射和工厂。
   - 反射：由Spring控制的，利用Java的反射机制，通过BeanDefinition的信息，实例化Bean。
   - 工厂方法：在配置Bean的时候，可以设置FactoryBean，如@Component中配置FactoryBean的实现类，这个类可以自己实现，用于生产这个Bean，因此是由用户控制的。包括@Bean的方式也是工厂方法，因为在方法中是我们自己return的new Bean()实例。
2. Bean的属性填充。循环依赖问题就出现在Bean填充属性的阶段。
3. 初始化Bean：调用initMethod、destroy方法等。
4. 将Bean注册到一级缓存(单例池)中：Map\<beanName,Bean\>。
5. 通过getBean()从一级缓存中获取到Bean。


### Spring IOC都有哪些扩展点？
&#8195;&#8195;SpringIOC提供了两类后置处理器的扩展，一类是Spring Context提供的再容器加载用的后置处理器，在Bean加载之前调用，专门用于扩展BeanDefinition，这部分BeanFactory没有实现：
- BeanFactoryPostProcessor：BeanFactory的后置处理器
  - 时机：Bean加载之前。
  - 作用：可以获取到BeanFactory，主要用于修改BeanDefinition。
- BeanDefinitionRegistryPostProcessor：BeanDefinition注册后置处理器
  - 时机：Bean加载之前。
  - 作用：可以获取到BeanFactoryRegistry，可以手动注册BeanDefinition到BeanFactory。Mapper的动态代理就是通过这里注入的BeanDefinition。

&#8195;&#8195;另一部分是BeanFactory实现的贯穿Bean生命周期9个后置处理器，都叫做BeanPostProcessor，专门用于扩展Bean：
- InstantiationAwareBeanPostProcessor#Before：
  - 时机：Bean实例化之前。
  - 作用：停止创建Bean或者自己返回自己创建的Bean，在AOP中用于解析切面Aspect。
- SmartInstantiationAwareBeanPostProcessor：
  - 时机：Bean实例化时。
  - 作用：指定实例化Bean的构造函数。
- MergedBeanDefinitionPostProcessor：
  - 时机：Bean属性填充之前。
  - 作用：预解析@Autowired、@Value。
- SmartInstantiationAwareBeanPostProcessor：
  - 时机：Bean属性填充之前。
  - 作用：解决循环引用AOP。
- InstantiationAwareBeanPostProcessor：
  - 时机：Bean属性填充时。
  - 作用：终止赋值。
- InstantiationAwareBeanPostProcessor：
  - 时机：Bean属性填充时。
  - 作用：注入属性PropertyValues(yml中的属性会被读为PropertyValues)，@Autowired也在这里DI。
- BeanPostProcessor#Before：
  - 时机：Bean初始化之前。
  - 作用：执行@PostConstruct。
- BeanPostProcessor#After：
  - 时机：Bean初始化之后。
  - 作用：创建AOP代理。
- DestructionAwareBeanPostProcessor：
  - 时机：初始化之后。
  - 作用：销毁已经创建的Bean。

&#8195;&#8195;除了后置处理器，还可以在Bean的所在类中，实现FactoryBean接口，并实现相关方法，来自定义Bean的实例化过程。

### Spring IOC容器如何解析配置类？
&#8195;&#8195;Spring IOC容器加载过程的准备阶段，会加载一个专门解析配置类相关的BeanFactoryPostProcessor，@Configuration、@ComponentScan、@Import等等注解都是由这个后置处理器进行解析。

&#8195;&#8195;解析时，会按顺序依次解析属性资源文件@PropertySource、
@ComponentScan、@Import、@ImportResource、@Bean。

&#8195;&#8195;在实例化时，使用cglib对配置类进行动态代理。之所以使用动态代理，主要是为了解决在配置类中使用@Bean。动态代理中做了一部分增强逻辑：
- 首先使用getBean从Spring IOC中获取bean。
- 获取不到才进行方法的实际创建。
- 创建完成后将@Bean方法创建的对象注册到容器中。


### 带有@Configuration和不带@Configuration有什么区别？
&#8195;&#8195;Spring IOC容器在使用内置BeanFactoryPostProcessor解析配置类时，会判断配置类是否带有@Configuration注解。如果带有@Configuration就认为是一个完整的配置类。如果没有此注解，而是带有@Bean和@Component注解，则认为是不完整的配置类。

### @ComponentScan如何被解析的？
&#8195;&#8195;在解析配置了时，会循环所有的@ComponentScan，判断包含的类集合和需要排除的类集合，并将所有的包合并起来，最终得到一个需要扫描路径。

&#8195;&#8195;BeanDefinitionScanner就是根据这个扫描路径扫描包下的所有类，找到所有的候选的BeanDefinition(扫描路径下不被排除的带有@Component族系注解的类都是候选)。

&#8195;&#8195;最终BeanFactory利用BeanDefinitionRegistry会把扫描到的候选BeanDefinition注册到Map中。

### 什么是循环依赖？
&#8195;&#8195;循环依赖指的是Bean A依赖Bean B，同时Bean B又依赖Bean A。那么在创建Bean A时发现依赖了Bean B，那么就会先去创建Bean B，但是此时发现B又依赖了A，进入了死循环。

&#8195;&#8195;循环依赖发生在Bean加载过程中的属性赋值阶段，会递归的加载所依赖的Bean。如果不解决这个问题，就会产生死循环。


### 循环依赖解决的大致思路？
&#8195;&#8195;循环依赖问题的产生其实就是产生了死循环。解决循环依赖其实就是在死循环中加一个出口就好了。解决这个问题的核心思路是，在Bean加载过程中，属性赋值之前，就将要加载的这个Bean先放入一级缓存中，也就是单例池中，这样在属性赋值时递归加载依赖Bean时，所依赖的Bean再回头获取时，就可以从缓存池中取到。

### 为什么需要二级缓存和三级缓存？分别是做什么的？
&#8195;&#8195;如果只有一级缓存，在多线程的情况下，Bean在加载过程的初期，一级缓存中的Bean实际上是个不完整的Bean，如果Bean没有创建完成，被另一个线程拿到，实际上是没法用的。那么此时需要二级缓存来暂存不完整的Bean。

&#8195;&#8195;所以二级缓存存放循环依赖的没有创建完成的Bean。

&#8195;&#8195;如果此时A使用了AOP，那么需要给A创建动态代理，动态代理在Bean初始化后使用BeanPostProcessor创建。初始化是在属性赋值之后做的，创建动态代理的过程在这后面，正常情况下是没有问题的，但是如果出现循环依赖，那么属性赋值时B依赖的A就不是动态代理对象了。

&#8195;&#8195;所以为了能够提前识别此Bean是循环依赖的问题，对象实例化之前，首先判断二级缓存中是否有实例，有则代表是循环依赖。同时为了职责单一，将AOP动态代理对象的创建时机不变，因此将需要创建动态代理的循环依赖Bean的函数接口存入三级缓存，在创建时直接调用接口。

&#8195;&#8195;因此三级缓存是存放循环依赖的Bean创建动态代理的接口的。

### Spring 如何解决的循环依赖问题？
&#8195;&#8195;Spring解决循环依赖使用的是三级缓存，就是三个ConcurrentHashMap。

&#8195;&#8195;循环依赖产生的原因：循环依赖问题的产生其实就是产生了死循环。解决循环依赖其实就是在死循环中加一个出口就好了。解决这个问题的核心思路是，在Bean加载过程中，属性赋值之前，就将要加载的这个Bean先放入一级缓存中，也就是单例池中，这样在属性赋值时递归加载依赖Bean时，所依赖的Bean再回头获取时，就可以从缓存池中取到。

&#8195;&#8195;如果只有一级缓存，在多线程的情况下，Bean在加载过程的初期，一级缓存中的Bean实际上是个不完整的Bean，如果Bean没有创建完成，被另一个线程拿到，实际上是没法用的。那么此时需要二级缓存来暂存不完整的Bean。

&#8195;&#8195;所以二级缓存存放循环依赖的没有创建完成的Bean。

&#8195;&#8195;如果此时A使用了AOP，那么需要给A创建动态代理，动态代理在Bean初始化后使用BeanPostProcessor创建。初始化是在属性赋值之后做的，创建动态代理的过程在这后面，正常情况下是没有问题的，但是如果出现循环依赖，那么属性赋值时B依赖的A就不是动态代理对象了。

&#8195;&#8195;所以为了能够提前识别此Bean是循环依赖的问题，对象实例化之前，首先判断二级缓存中是否有实例，有则代表是循环依赖。同时为了职责单一，将AOP动态代理对象的创建时机不变，因此将需要创建动态代理的循环依赖Bean的函数接口存入三级缓存，在创建时直接调用接口。

&#8195;&#8195;因此三级缓存是存放循环依赖的Bean创建动态代理的接口的。

### Spring有没有解决构造函数的循环依赖？
&#8195;&#8195;没有，构造函数是在Bean实例化时创建的，此时Bean的实例都没创建，因此也不会存在于一级缓存和二级缓存中，因此也没法判断是否是循环依赖，也无从解决。如果构造函数循环依赖，那么会报错。

### Spring有没有解决多例模式下的循环依赖？
&#8195;&#8195;多例模式不存在于一级缓存的单例池，毕竟不是单例的，每次使用创建一个实例即可，因此如果多例有循环依赖直接抛异常了。

### 如何创建一个Spring监听器？
- 实现事件：继承ApplicationEvent。
- 实现监听器：实现ApplicationListener\<ApplicationEvent\>接口，接口中的方法就是监听对应事件的方法。或者使用@EventListener(ApplicationEvent.class)
- 发布事件：使用Spring上下文ApplicationContext.publishEvent()发布事件。

&#8195;&#8195;大的分布式项目一般用MQ了，小的项目一般也用不到。很多是用于框架集成使用，如Nacos通过异步监听的方式进行配置推送和服务变更推送。

### Spring事件监听机制是什么？
&#8195;&#8195;Spring的事件监听采用的也是观察者模式，Spring上下文提供了事件发布的能力，用户通过实现事件和实现监听器完成订阅。

&#8195;&#8195;监听器加载是在Spring IOC容器加载时完成的：
1. 首先，Spring IOC容器会将我们声明的监听器注册到多播器上，包括注解实现的和接口实现的所有监听器。
2. 多播器广播原理：
   1. 调用ApplicationContext的事件发布接口，会从容器中拿到多播器
   2. 在多播器中根据发布的事件类型，找到对应的监听器
   3. 如果多播器在配置类中设置了异步的Executor，那么会使用使用异步的方式开启一个新线程执行监听逻辑。
   4. 如果没有指定异步多播器，那么会同步执行。


## Spring AOP
### Spring AOP的实现原理？
&#8195;&#8195;Spring在实现AOP时，如果使用的接口，用的JDK的动态代理实现，如果没有使用接口，则是使用的CGLIB实现。JDK的动态代理是通过JVM修改字节码的方式实现的，CGLIB是利用ASM库修改字节码的方式实现的。Spring AOP提供了AspectJ的支持。

&#8195;&#8195;代理对象的生成主要包含了两个大步骤，一个是解析切面，一个是根据切面生成代理。

&#8195;&#8195;在Spring IOC容器加载时，在第一个BeanPostProcessor中解析切面，为每一个带有@Aspectj注解的Bean生成一个Advicor。

&#8195;&#8195;在Spring IOC容器初始化Bean后，会有一个BeanPostProcessor用于创建AOP代理：
1. 获取到所有解析过的Advicor。
2. 拿到每一个Advicor的Pointcut。
3. 利用Pointcut设置的方法名匹配Bean的方法名，匹配(策略模式)上说明可以创建动态代理。
4. 为Bean创建动态代理对象。
5. 将代理对象存入一级缓存。

&#8195;&#8195;在调用时，会把所有的增强Advicor转换为Interceptor，用责任链模式依次调用前置、未增强方法、后置、环绕。

## Spring 事务机制
### Spring事务的传播行为
- REQUIRED(默认级别)：
  - 外部不存在事务时：开启新事务。
  - 外部存在事务时：融合到外部事务中，与外部事务组成同一个事务。
  - 场景：增删改查。
- SUPPORTS：
  - 外部不存在事务时：不开启新事务。
  - 外部存在事务时：融合到外部事务中。
  - 场景：查询。
- REQUIRES_NEW：
  - 外部不存在事务时：开启新事务。
  - 外部存在事务时：挂起外部事物，创建此事务范围的新事务。
  - 场景：内部事务与外部事务不兼容。
- NOT_SUPPORTED：
  - 外部不存在事务时：不开启新事务。
  - 外部存在事务时：挂起外部事务。
  - 场景：不常用，仅仅用于某些情况不适合事务处理时。
- NEVER：
  - 外部不存在事务：不开启新事务。
  - 外部存在事务：报错。
  - 场景：不常用，仅用于禁止事务的场景。
- MANDATORY：
  - 外部不存在事务：抛出异常。
  - 外部存在事务：融合到外部事务。
  - 场景：不常用，仅用于高层级接口规定的事务时。
- NESTED：
  - 外部不存在事务时：开启新事务。
  - 外部存在事务时：SavePoint机制，把内层事务单独看做一个原子操作融合到外层。
  - 场景：不常用。


### Spring 事务的实现原理
&#8195;&#8195;Spring声明式事务是基于Spring AOP的机制实现的，同样需要加载切面、创建代理和调用代理。事务增强的传播行为等逻辑，是Spring内置好的一套逻辑。

&#8195;&#8195;在Spring IOC容器加载时的准备阶段，利用内置的BeanFactoryPostProcessor**解析配置类时**会解析@Import注解，与事务相关的注册动作有2个：
- 注册一个BeanPostProcessor，用于生成事务代理Bean。
- 注册一个与事务相关的Advicor的Bean。

&#8195;&#8195;事务代理切面的解析与AOP相同，在第一个BeanPostProcessor中，调用的实现就是上述注册的实现，但是由于Advicor是内置的而且在准备阶段已经注册，因此在这里直接将上一步的Advicor放入Advicor的集合中，给生成代理的PostProcessor使用。

&#8195;&#8195;生成代理对象的BeanPostProcessor中，与事务相关的逻辑是这样的：
1. Pointcut匹配方法时，匹配的是@Transaction注解的方法而不是方法名。
2. 根据@Transaction注解生成注解属性实例，包含注解里设置的属性和修饰方法的全限定名。
3. 根据属性信息为类创建事务代理对象，在事务的方法上做增强。

&#8195;&#8195;事务调用时，执行事务代理方法，对于没有事务嵌套的：
1. 使用TransactionManager开启事务
2. 使用责任链执行具体的方法
3. catch异常执行回滚
4. 没有问题执行完成执行提交

&#8195;&#8195;有嵌套事务时，会根据事务的传播行为判断开启事务的点。

### 为什么内部方法调用事务会失效？
&#8195;&#8195;Spring事务机制是基于AOP实现的，AOP的代理对象执行方法是利用责任链把before、环绕、方法本身、after这些增强依次执行的。

&#8195;&#8195;使用内部方法调用时，仅仅是责任链中执行方法本身的那一环节invoke()方法而已，并不具备增强的逻辑。

## Spring MVC
### Spring MVC的执行流程以及核心组件？
&#8195;&#8195;SpringMVC有以下几个核心组件：
- DispatcherServlet：前端控制器。
- HandlerMapping：处理器映射器。
- HandlerAdapter：处理器适配器。
- Controller：控制器。
- ViewResoler：视图解析器。

&#8195;&#8195;SpringMVC处理请求的大致流程是这样的：
1. 客户端发送请求，被DispatcherServlet接收。
2. DispatcherServlet交给HandlerMapping查询执行链路Chain，包括Interceptor链路和Controller。
3. DispatcherServlet把请求和执行链路交给HandlerAdapter负责执行。
4. Controller返回ModelAndView给HandlerAdapter。
5. DispatcherServlet将ModelAndView交给ViewResolver解析为View，然后返回给客户端。

### Spring 容器和Spring MVC容器是什么关系？
&#8195;&#8195;Spring容器是管理Spring Bean的地方，通俗的理解，@Service、@Mapper等都是Spring 容器管理。@Controller则是由Spring MVC的容器管理。类似的还有LoadBalancer的容器、OpenFeign的容器，分别管理自己的Bean的实现。

## Mybatis
### Mybatis的整体架构
&#8195;&#8195;Mybatis分为三层，由顶向下分别是：接口层、数据处理层、基础支撑层。
- 接口层：由**SqlSession**提供了增删改查等一系列的数据操作接口。
- 数据处理层：参数映射(ParameterHandler)、Sql解析(SqlSource)、Sql执行(Executor)、结果映射(ResultSetHandler)。
- 基础支撑层：基于xml和注解的Sql语句配置、连接管理、事务管理、配置加载、缓存处理、配置架构。

### 什么是Mybaits的一级缓存和二级缓存？
&#8195;&#8195;在一次Mybatis会话中，也就是一次SqlSession中，所有的查询操作都会保存到缓存中(一级缓存默认开启)。一般来说，一个请求中的所有增删改查操作都是由一个SqlSession完成的，因此可以认为每一个请求都有一个一级缓存。

&#8195;&#8195;如果同一个操作中两次相同的查询中有一个update、insert、delete语句，那么一级缓存会被清除。因为每次对同一个表的增删改查操作都有可能修改数据，因此需要刷新缓存。

&#8195;&#8195;一级缓存是针对会话的，二级缓存是全局的，需要手动开启。一个SqlSession会话关闭时，会将其一级缓存刷新到二级缓存中，当另一个SqlSession执行时，会首先查询二级缓存，当二级缓存不被命中时，才会查询数据库。

&#8195;&#8195;每一条语句都有一个缓存key，value就是缓存结果。缓存key包含sql语句、参数、方法全限定路径。因此能够通过缓存key判断是否是同一条语句。一级缓存是保存在SqlSession的，因此能保证每一个会话都有其独立的一级缓存。

### Mybatis如何解析配置文件？
&#8195;&#8195;SqlSessionFactory通过加载配置文件，将其解析为Configuration对象，SqlSessionFactory中使用构造器模式，将xml文件属性全都读取为Configuration。

&#8195;&#8195;Mybatis的构造器都实现了BaseBuilder接口，提供了有很多实现，用于解析不通的内容：MyBatis配置文件、Mybatis全局配置文件、Mapper、Sql语句、节点等。各种Builder会把对应的内容解析为Crud节点信息、结果映射、参数映射等存入Configuration。

&#8195;&#8195;需要注意的是，解析Mapper的XML文件时，会解析二级缓存：
1. 解析\<cache\>标签配置，生成Cache对象。
2. 使用装饰器模式把一层层的Cache缓存实现类装饰起来。
3. 把缓存对象放到Configuration中。

### Mybatis如何解析Sql？
&#8195;&#8195;Mybatis使用SqlSource解析Sql。在加载过程时，已经将Sql执行的所需要的节点信息等加载到了Configuration。Mybatis会使用责任链模式，依次解析所有的SqlNode，最终拼装为Sql存放在SqlSource中。

### Mybatis如何实现参数映射？
&#8195;&#8195;SqlSource解析Sql时，会将Sql标签中的参数替换为问号。当参数传入时，ParameterHandler根据参数找到对应的类型，并根据类型找到对应的TypeHandler。利用类型处理器将问号替换为对应参数名称的参数。

### Mybatis如何解析查询结果？
&#8195;&#8195;ResultSetHandler根据xml中设置的ResultSet的映射关系，依次解析查询到的ResultSet。

### Mybatis如何执行数据查询？
&#8195;&#8195;Mybatis的执行器(Executor)的实现有5种，分别是Simple、Reuse(重复)、Batch(批量)、Caching(开启二级缓存)、BaseExecutor(一级缓存)。Mybatis使用门面模式，将Simple、Reuse、Batch委托给Base和Caching，首先执行Base和Caching的修饰，再执行Simple、Reuse、Batch的具体逻辑。

### Mybatis的插件(Plugin)执行原理是什么？
&#8195;&#8195;Mybatis插件增强是通过动态代理增强底层的四个核心对象，以拦截器的形式进行增强，或者说指定需要拦截的类的方法，为方法创建动态代理。插件创建的时机是当SqlSessionFactory解析配置文件时，在Configuration创建四个核心对象时，遍历InterceptorChain为对应的类的方法创建动态代理。：
- Executor(执行器)：增强sql的增删查改方法、flushStatement、提交回滚等。相当于追加标签来拼接sql。
- ParameterHandler(参数映射)：getParameterObjet、setParameter。
- ResultSetHandler(结果映射)：增强handleResultSet、handleOutputParameter。
- StatementHandler(sql执行者)：prepare、parameterize、batch、update、query。

### Mybatis如何利用Spring扩展点进行整合？
1. 初始化：
   1. 通过自动装配注入SqlSessionFactoryBean。
   2. SqlSessionFactoryBean构建SqlSessionFactory。
   3. SqlSessionFactory将所有的配置加载到Configuration，并构建XmlMapperBuilder，用来解析XmlMapper。
   4. SqlSessionFactoryBean注入Spring的TransactionManager获取Connection，并配置到Configuration。
2. 管理@Mapper动态代理：
   1. 利用BeanDefinitionRegistryPostProcessor注册BeanDefinition。
   2. Mybatis实现了一个自己的BeanDefinitionScanner，专门扫描@Mapper。
   3. 定义一个**FactoryBean接口(大多数的框架集成都是用的这个)**，将所有@Mapper接口都实现为FactoryBean，实现对所有@Mapper接口的动态代理。
   4. 在FactoryBean控制实例化时，拿到Configuration中的Xml配置信息，然后将动态代理的对象通过FactoryBean提供的getObject()方法返回给Spring容器。
   5. 通过定义BeanDefinition，生成@Mapper的Bean。

&#8195;&#8195;也就是说，Mybatis在创建@Mapper类的动态代理过程是利用SpringIOC容器的扩展机制：
- BeanDefinitionRegistryPostProcessor将Mapper接口注册为Bean。
- 使用FactoryBean机制，使用动态代理把Bean对象转换为代理对象。

## SpringBoot
### @Import的用法？
- @Import(Class)：将该类注册为一个Bean。
- @Import(ImportSelector.class)：参数是实现了ImportSelector接口的类，通过返回一个类路径的数组，可以一次性注册很多Bean。

### 为什么SpringBoot不使用ImportSelector的方式注入配置类？
&#8195;&#8195;主要是扩展性问题，使用@Import注解引入ImportSelector接口，虽然能够一次性的注入多个Bean，但是只能注入固定的Bean，用过用户需要加载自定义的框架配置类实现，通过SPI机制是可以做到很好的插拔效果的。

&#8195;&#8195;其次，使用@ConditionOn注解来进行判断注入自定义还是默认的Bean，由于Bean注入的顺序无法控制，也无法完成用户注入自定义框架配置类实现的要求。

### DeferredImportSelector对Bean的加载顺序的影响？
&#8195;&#8195;DeferredImportSelector可以控制Bean注入的顺序。使用@Import注入Bean时，如果实现了DeferredImportSelector，那么用它注入的Bean时延迟加载的。

&#8195;&#8195;在Spring IOC加载的准备阶段，会扫描注入配置类的BeanDefinition，包括@Bean、@Import等等，DeferredImportSelector会在所有的需要提前注入的Bean注入完成后，再延迟加载，其顺序是在后面的。

&#8195;&#8195;另外，DeferredImportSelector提供了分组功能，会调用用户重写实现的分组功能，比如实现当前组内BeanDefinition注册时的顺序，整个组的注册会在SpringIOC加载配置Bean之后，因此顺序是可控的。

### SpringBoot自动装配原理？
&#8195;&#8195;SpringBoot利用@Import导入DeferredImportSelector延迟注册的原理。SpringBoot把需要加载的Bean都写在了META-INFO/Spring.factories文件中，在分组中读取文件中类的全限定名，然后注册为BeanDefinition。

&#8195;&#8195;在加载spring.factories时，会根据条件进行过滤，如文件中配置为xxx.OnClassCondition的类时，就会判断是否生效。

### 如何实现一个自定义的Starter完成自动装配？
1. 在自己实现的Starter中仙剑META-INFO/spring.factories
2. 文件中指向自己的自动配置类全限定名：
```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
cn.demo.HelloAutoConfiguration
```
3. 自己的自动配置类使用@Configuration注入，使用@ConditionalOnProperty配置生效规则，使用@EnableConfigurationProperties配置生效属性。


### SpringBoot为什么Jar包可以直接运行？
&#8195;&#8195;通过添加spring-boot-maven-plugin插件，可以直接使用java -jar启动SpringBoot程序。插件会自动编写MANIFEST.MF文件，并且将依赖的Jar包打包到程序的Jar包中。

&#8195;&#8195;MANIFEST.MF文件中，指定了项目的启动类、Jar包路径、MainClass等一系列信息。

&#8195;&#8195;Java没有提供标准的ClassLoader加载嵌套的Jar文件，MainClass属性指定的就是SpringBoot项目加载类用的ClassLoader。使用Java -jar启动时使用的是指定的JarLaunch，会加载SpringBoot依赖的Jar包。

### SpringBoot如何启动Spring容器？
&#8195;&#8195;SpringBoot在启动时，SpringApplication初始化时(new SpringApplication)：
1. 初始化一个Spring容器(ApplicationContext)。
2. 读取ApplicationListener监听器。

&#8195;&#8195;Spring容器启动的流程与之前说的相同。需要额外关注的是：
- Tomcat的初始化是在Spring容器的refresh中完成的。
- 在refresh方法中，会扫描spring.factories加载需要自动装配的类。

&#8195;&#8195;之后是执行run()方法：
1. 发布ApplicationStartingEvent，用于扩展SpringBoot
2. 发布ApplicationEnvironmentPreparedEvent：通知监听器可以对配置文件进行读取操作了，读取配置文件就是基于监听器。
3. 读取和封装环境配置信息，全部封装为@ConfigurationProperties。
4. 实例化Spring上下文。
5. Spring容器加载：
   - 会额外发布一个ApplicationContextInitiatializedEvent。
   - 将SpringBoot的监听器加载到多播器。
   - 发布SpringApplicationPreparedEvent。 

### SpringBoot的SPI机制？
&#8195;&#8195;Java的SPI机制是一种服务发现机制，可以通过读取ClassPath下META-INFO/services文件，自动加载接口的类。

&#8195;&#8195;SpringBoot的实现并不是利用SPI机制，只是借鉴了SPI的思想。JavaSPI的核心是，通过配置接口，自动找到实现类。SpringBoot则是配置实现类，去加载这些类，并注册到Spring的容器中。

