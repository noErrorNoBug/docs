<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.36" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://github.com/noErrorNoBug/docs/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html"><meta property="og:site_name" content="后端技术笔记"><meta property="og:title" content="Java面试题"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><link rel="icon" href="./favicon.ico"><meta name="author" content="noErrorNoBug"><meta name="keywords" content="java,JVM,并发,算法,mysql,redis,mongodb,elasticsearch,spring,springboot,netty,mq,kafka,分布式,微服务,商城,秒杀,数据仓储,网络协议,Docker,Linux"><link rel="manifest" href="/docs/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#F0FFF0"><link rel="apple-touch-icon" href="/icons/icon-192x192.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="white"><link rel="mask-icon" href="/icons/icon-256x256.png" color="#F0FFF0"><meta name="msapplication-TileImage" content="/icons/icon-384x384.png"><meta name="msapplication-TileColor" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>Java面试题 | 后端技术笔记</title><meta name="description" content="noErrorNoBug(sunqiang)的后端技术笔记">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/docs/assets/style.004f05f4.css">
    <link rel="modulepreload" href="/docs/assets/app.7eb989d9.js"><link rel="modulepreload" href="/docs/assets/Java面试题.html.52230c6d.js"><link rel="modulepreload" href="/docs/assets/Java面试题.html.686dc01f.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container no-sidebar has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/docs/" class="home-link"><img class="logo light" src="/docs/logo.svg" alt="后端技术笔记"><img class="logo dark light" src="/docs/logo.svg" alt="后端技术笔记"><span class="site-name hide-in-pad">后端技术笔记</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="面试题"><span class="title"><!---->面试题</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="router-link-active router-link-exact-active nav-link active" arialabel="Java面试题"><!---->Java面试题<!----></a></li><li class="dropdown-item"><a href="/docs/questions/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="nav-link" arialabel="数据存储中间件面试题"><!---->数据存储中间件面试题<!----></a></li><li class="dropdown-item"><a href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="nav-link" arialabel="框架中间件面试题"><!---->框架中间件面试题<!----></a></li><li class="dropdown-item"><a href="/docs/questions/%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="nav-link" arialabel="分布式和微服务面试题"><!---->分布式和微服务面试题<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="Java"><span class="title"><!---->Java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>面向对象|基础</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/java/basic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html" class="nav-link" arialabel="面向对象特性"><!---->面向对象特性<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/basic/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="nav-link" arialabel="Java基础知识"><!---->Java基础知识<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/basic/Java%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6.html" class="nav-link" arialabel="Java高级特性"><!---->Java高级特性<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JAVA 集合框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Collection 集合"><!---->Collection 集合<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Map 集合"><!---->Map 集合<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="并发集合框架"><!---->并发集合框架<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JAVA 并发框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="并发理论基础"><!---->并发理论基础<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="多线程基础"><!---->多线程基础<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="关键字详解"><!---->关键字详解<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="集合与并发集合"><!---->集合与并发集合<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="线程池"><!---->线程池<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="CAS原理和原子类"><!---->CAS原理和原子类<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="AQS原理和锁机制"><!---->AQS原理和锁机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="并发流程控制"><!---->并发流程控制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Disruptor框架"><!---->Disruptor框架<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="ThreadLocal"><!---->ThreadLocal<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="并发设计模式"><!---->并发设计模式<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JAVA IO框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="JAVA IO"><!---->JAVA IO<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="JAVA NIO"><!---->JAVA NIO<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JVM原理</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link" arialabel="JVM类加载机制"><!---->JVM类加载机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link" arialabel="JVM内存知识"><!---->JVM内存知识<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html" class="nav-link" arialabel="JVM垃圾回收原理"><!---->JVM垃圾回收原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/jvm/%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" class="nav-link" arialabel="JVM调优思路"><!---->JVM调优思路<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html" class="nav-link" arialabel="JVM线上调试排查"><!---->JVM线上调试排查<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JAVA 版本特性</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/java/version/java8/java8%E7%89%B9%E6%80%A7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html" class="nav-link" arialabel="Java8特性"><!---->Java8特性<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/version/java11/java9%E5%88%B0java11%E7%89%B9%E6%80%A7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html" class="nav-link" arialabel="java8升java11特性"><!---->java8升java11特性<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/version/java17/java12%E5%88%B0java17%E7%89%B9%E6%80%A7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html" class="nav-link" arialabel="java11升java17特性"><!---->java11升java17特性<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="算法"><span class="title"><!---->算法</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据结构</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="复杂度析分析"><!---->复杂度析分析<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="线性表相关数据结构"><!---->线性表相关数据结构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="树相关数据结构"><!---->树相关数据结构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="堆相关数据结构"><!---->堆相关数据结构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="图相关数据结构"><!---->图相关数据结构<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>常用算法</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="排序算法"><!---->排序算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="查找算法"><!---->查找算法<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>算法思想</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="动态规划"><!---->动态规划<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分治算法"><!---->分治算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="二分法"><!---->二分法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="搜索算法"><!---->搜索算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="回溯算法"><!---->回溯算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="贪心算法"><!---->贪心算法<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>领域算法实践</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="加密算法"><!---->加密算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="字符串匹配算法"><!---->字符串匹配算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据一致性算法"><!---->数据一致性算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="负载均衡算法"><!---->负载均衡算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/algorithm/domain/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95.html" class="nav-link" arialabel="限流算法"><!---->限流算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据处理算法"><!---->数据处理算法<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="数据库"><span class="title"><!---->数据库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据库基础</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据库理论"><!---->数据库理论<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="SQL语言"><!---->SQL语言<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>SQL数据库 Mysql</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="索引原理"><!---->索引原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="存储引擎"><!---->存储引擎<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构原理"><!---->架构原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="事务机制"><!---->事务机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="性能优化"><!---->性能优化<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分库分表和读写分离"><!---->分库分表和读写分离<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Nosql数据库 Redis</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据类型和数据结构"><!---->数据类型和数据结构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高可用集群原理"><!---->高可用集群原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据持久化原理"><!---->数据持久化原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高性能原理"><!---->高性能原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="性能优化要点"><!---->性能优化要点<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="典型应用实现"><!---->典型应用实现<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Nosql数据库 ElasticSearch</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Elastic Stack生态"><!---->Elastic Stack生态<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="查询和聚合"><!---->查询和聚合<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="复杂搜索策略"><!---->复杂搜索策略<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="聚合匹配"><!---->聚合匹配<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据建模"><!---->数据建模<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="核心原理"><!---->核心原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="优化思路"><!---->优化思路<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="框架|中间件"><span class="title"><!---->框架|中间件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring Framework</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="控制反转(IOC)"><!---->控制反转(IOC)<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="面向切面编程(AOP)"><!---->面向切面编程(AOP)<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="事务机制"><!---->事务机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="MVC机制"><!---->MVC机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="基于注解配置"><!---->基于注解配置<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="WebFlux"><!---->WebFlux<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring Boot</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="约定大于配置"><!---->约定大于配置<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="自动装配原理"><!---->自动装配原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="组件集成"><!---->组件集成<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>ORM框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Mybatis核心原理"><!---->Mybatis核心原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Mybatis-Plus简化开发"><!---->Mybatis-Plus简化开发<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="WEB容器"><span class="title"><!---->WEB容器</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Nginx容器</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构及配置"><!---->架构及配置<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="性能调优"><!---->性能调优<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Tomcat容器</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Web请求过程"><!---->Web请求过程<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="启停原理"><!---->启停原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="网络原理"><!---->网络原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="热加载和热部署"><!---->热加载和热部署<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Netty容器</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Netty核心架构"><!---->Netty核心架构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Netty线程模型实现原理"><!---->Netty线程模型实现原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Netty数据交换实现原理"><!---->Netty数据交换实现原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Netty优化"><!---->Netty优化<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="消息队列"><span class="title"><!---->消息队列</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>RocketMQ</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="TODO"><!---->TODO<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Kafka</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Kafka核心原理"><!---->Kafka核心原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="典型应用方案"><!---->典型应用方案<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="调优思路分析"><!---->调优思路分析<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>RabbitMQ</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构原理"><!---->架构原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="集群原理"><!---->集群原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="典型应用方案"><!---->典型应用方案<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="微服务"><span class="title"><!---->微服务</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring Cloud 生态</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/microservice/loadbalance/LoadBalancer%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="LoadBalancer:负载均衡器"><!---->LoadBalancer:负载均衡器<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/feign/OpenFeign%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="OpenFeign:函数式调用"><!---->OpenFeign:函数式调用<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/gateway/Gateway%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="Gateway:高可用网关API"><!---->Gateway:高可用网关API<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/auth/SpringSecurity%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="Security:认证和授权"><!---->Security:认证和授权<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="SkyWalking:链路追踪"><!---->SkyWalking:链路追踪<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="SpringCloud扩展点"><!---->SpringCloud扩展点<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring Cloud Alibaba 生态</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/microservice/register/%E5%9F%BA%E4%BA%8EAP%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="Nacos:服务注册与发现"><!---->Nacos:服务注册与发现<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/config/%E5%9F%BA%E4%BA%8ENacos%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0.html" class="nav-link" arialabel="Nacos:配置中心"><!---->Nacos:配置中心<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/sentinel/%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81.html" class="nav-link" arialabel="Sentinel:限流和降级"><!---->Sentinel:限流和降级<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Seata:分布式事务"><!---->Seata:分布式事务<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="方法论|系统设计"><span class="title"><!---->方法论|系统设计</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>开发原则</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="代码设计原则"><!---->代码设计原则<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="代码规范和重构"><!---->代码规范和重构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="开源协议和系统认证"><!---->开源协议和系统认证<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>设计模式范式</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/patterns/build/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html" class="nav-link" arialabel="创建型范式"><!---->创建型范式<!----></a></li><li class="dropdown-subitem"><a href="/docs/patterns/construct/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html" class="nav-link" arialabel="结构型范式"><!---->结构型范式<!----></a></li><li class="dropdown-subitem"><a href="/docs/patterns/action/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.html" class="nav-link" arialabel="行为型范式"><!---->行为型范式<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>分布式理论</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/methodology/distribution/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9.html" class="nav-link" arialabel="分布式理论和模型"><!---->分布式理论和模型<!----></a></li><li class="dropdown-subitem"><a href="/docs/methodology/transaction/X_OPEN%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.html" class="nav-link" arialabel="分布式事务理论"><!---->分布式事务理论<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="微服务理论"><!---->微服务理论<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="架构|分布式"><span class="title"><!---->架构|分布式</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>系统架构</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构视角及演进"><!---->架构视角及演进<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构的模式与核心要素"><!---->架构的模式与核心要素<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高并发架构要素"><!---->高并发架构要素<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高可用架构要素"><!---->高可用架构要素<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高性能架构要素"><!---->高性能架构要素<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>分布式系统设计</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="全局唯一ID"><!---->全局唯一ID<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式锁"><!---->分布式锁<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式事务"><!---->分布式事务<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式缓存"><!---->分布式缓存<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式任务"><!---->分布式任务<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式会话"><!---->分布式会话<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式链路追踪"><!---->分布式链路追踪<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式文件"><!---->分布式文件<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式存储"><!---->分布式存储<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式计算"><!---->分布式计算<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>系统设计案例</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="秒杀系统案例"><!---->秒杀系统案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="后台管理系统案例"><!---->后台管理系统案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据同步案例"><!---->数据同步案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="商城架构案例"><!---->商城架构案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="轻量单体限流框架案例"><!---->轻量单体限流框架案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="轻量消息系统案例"><!---->轻量消息系统案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="OSS单点登录案例"><!---->OSS单点登录案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高可用网关案例"><!---->高可用网关案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="认证授权服务案例"><!---->认证授权服务案例<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="大数据"><span class="title"><!---->大数据</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据同步</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="canal:数据库准实时同步"><!---->canal:数据库准实时同步<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>日志收集</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="ELK日志数据收集"><!---->ELK日志数据收集<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="项目|优化"><span class="title"><!---->项目|优化</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>系统性能优化</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Java编程性能调优"><!---->Java编程性能调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="多线程调优"><!---->多线程调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="JVM性能检测及调优"><!---->JVM性能检测及调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="设计模式调优"><!---->设计模式调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据库调优"><!---->数据库调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="基础设施优化"><!---->基础设施优化<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="系统网络调优"><!---->系统网络调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式系统优化"><!---->分布式系统优化<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="业务开发优化"><!---->业务开发优化<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>项目重构|项目设计</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="一套分布式高可用架构选型"><!---->一套分布式高可用架构选型<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="商城系统"><!---->商城系统<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="秒杀系统"><!---->秒杀系统<!----></a></li><li class="dropdown-subitem"><a href="/docs/projects/uua/UUA%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B.html" class="nav-link" arialabel="认证授权系统"><!---->认证授权系统<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="日志中心系统"><!---->日志中心系统<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="基于数据库的订阅中心"><!---->基于数据库的订阅中心<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高可用网关方案"><!---->高可用网关方案<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="单机可插拔限流框架"><!---->单机可插拔限流框架<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="幂等性框架"><!---->幂等性框架<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="基于Flink的实时推荐系统"><!---->基于Flink的实时推荐系统<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="工具|部署"><span class="title"><!---->工具|部署</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>开发工具</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="常用类库"><!---->常用类库<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="代码质量保障"><!---->代码质量保障<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="常用表达式"><!---->常用表达式<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="代码安全"><!---->代码安全<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Linux|Shell脚本</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Shell脚本"><!---->Shell脚本<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="文本操作命令"><!---->文本操作命令<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="系统操作命令"><!---->系统操作命令<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="系统管理命令"><!---->系统管理命令<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>网络协议|抓包工具</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Http1.1协议"><!---->Http1.1协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="WebSocket协议"><!---->WebSocket协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Http2协议"><!---->Http2协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="TLS/SSL协议"><!---->TLS/SSL协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="TCP协议"><!---->TCP协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="UDP协议"><!---->UDP协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="IP协议"><!---->IP协议<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Docker容器化</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="容器进程管理"><!---->容器进程管理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="容器内存管理"><!---->容器内存管理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="容器存储管理"><!---->容器存储管理<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>代码管理|依赖管理</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Git常用功能"><!---->Git常用功能<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分支管理模式"><!---->分支管理模式<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Maven依赖管理"><!---->Maven依赖管理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="GitHub常用功能"><!---->GitHub常用功能<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="常用开源工具"><!---->常用开源工具<!----></a></li></ul></li></ul></button></div></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/noErrorNoBug" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar hide-icon"><!--[--><!----><!--]--><ul class="sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->Java面试题</h1><div class="article-info"><span class="author-info" arialabel="作者🖊" data-balloon-pos="down" isoriginal="false" pageview="false" color="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" arialabelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://noerrornobug.github.io/docs/" target="_blank" rel="noopener noreferrer">noErrorNoBug(sunqiang)</a></span><span property="author" content="noErrorNoBug(sunqiang)"></span></span><span class="date-info" arialabel="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false" color="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年9月4日</span><meta property="datePublished" content="2022-09-04T08:16:00.000Z"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#jvm原理" class="router-link-active router-link-exact-active toc-link level2">JVM原理</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#请简单说一下类的加载过程" class="router-link-active router-link-exact-active toc-link level3">请简单说一下类的加载过程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#jvm提供了哪些类加载器-类加载器如何初始化的" class="router-link-active router-link-exact-active toc-link level3">JVM提供了哪些类加载器？类加载器如何初始化的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何自定义类加载" class="router-link-active router-link-exact-active toc-link level3">如何自定义类加载？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是双亲委派机制" class="router-link-active router-link-exact-active toc-link level3">什么是双亲委派机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何打破双亲委派机制-tomcat是如何打破双亲委派机制的" class="router-link-active router-link-exact-active toc-link level3">如何打破双亲委派机制？Tomcat是如何打破双亲委派机制的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的spi机制-如何实现" class="router-link-active router-link-exact-active toc-link level3">什么是Java的SPI机制？如何实现？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是jvm的内存模型-都有哪几部分组成-各有什么作用" class="router-link-active router-link-exact-active toc-link level3">什么是JVM的内存模型？都有哪几部分组成？各有什么作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#堆内存如何划分的-数据在堆内存中如何流转的" class="router-link-active router-link-exact-active toc-link level3">堆内存如何划分的？数据在堆内存中如何流转的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java如何创建一个对象" class="router-link-active router-link-exact-active toc-link level3">Java如何创建一个对象？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java对象头的结构是什么样的" class="router-link-active router-link-exact-active toc-link level3">Java对象头的结构是什么样的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java对象在栈内如何分配的" class="router-link-active router-link-exact-active toc-link level3">Java对象在栈内如何分配的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java对象在eden区如何分配的" class="router-link-active router-link-exact-active toc-link level3">Java对象在Eden区如何分配的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#老年代都存放哪些对象" class="router-link-active router-link-exact-active toc-link level3">老年代都存放哪些对象？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java大对象在内存中如何分配" class="router-link-active router-link-exact-active toc-link level3">Java大对象在内存中如何分配？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#长期存活的对象存放在哪儿" class="router-link-active router-link-exact-active toc-link level3">长期存活的对象存放在哪儿？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是对象的动态年龄判断机制" class="router-link-active router-link-exact-active toc-link level3">什么是对象的动态年龄判断机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是老年代空间分配的担保机制" class="router-link-active router-link-exact-active toc-link level3">什么是老年代空间分配的担保机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#jvm提供了哪些引用类型" class="router-link-active router-link-exact-active toc-link level3">JVM提供了哪些引用类型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何判断一个对象是否应该被回收" class="router-link-active router-link-exact-active toc-link level3">如何判断一个对象是否应该被回收？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#finalize-方法的作用是什么" class="router-link-active router-link-exact-active toc-link level3">finalize()方法的作用是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何判断一个类是无用的类" class="router-link-active router-link-exact-active toc-link level3">如何判断一个类是无用的类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#有哪些垃圾回收算法" class="router-link-active router-link-exact-active toc-link level3">有哪些垃圾回收算法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#常用的垃圾回收器有哪些" class="router-link-active router-link-exact-active toc-link level3">常用的垃圾回收器有哪些？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何选择合适的垃圾回收器" class="router-link-active router-link-exact-active toc-link level3">如何选择合适的垃圾回收器？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#jvm调优" class="router-link-active router-link-exact-active toc-link level2">JVM调优</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#平常都是怎么做jvm调优的-调优的思路" class="router-link-active router-link-exact-active toc-link level3">平常都是怎么做JVM调优的(调优的思路)？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如果发生cpu使用率偏高、内存偏高等具体的问题-调优的思路是什么" class="router-link-active router-link-exact-active toc-link level3">如果发生CPU使用率偏高、内存偏高等具体的问题，调优的思路是什么？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java并发" class="router-link-active router-link-exact-active toc-link level2">Java并发</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#cpu的三层缓存架构" class="router-link-active router-link-exact-active toc-link level3">CPU的三层缓存架构？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是用户态-什么是内核态-操作系统如何管理内存" class="router-link-active router-link-exact-active toc-link level3">什么是用户态，什么是内核态？操作系统如何管理内存？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是jmm内存模型" class="router-link-active router-link-exact-active toc-link level3">什么是JMM内存模型？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#简述一下线程安全的三个特性" class="router-link-active router-link-exact-active toc-link level3">简述一下线程安全的三个特性？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#volatile关键字的作用是怎样的-如何实现的" class="router-link-active router-link-exact-active toc-link level3">volatile关键字的作用是怎样的？如何实现的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#简述一下final关键字和不变性原理" class="router-link-active router-link-exact-active toc-link level3">简述一下final关键字和不变性原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#synchronized关键字的作用是什么" class="router-link-active router-link-exact-active toc-link level3">synchronized关键字的作用是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#synchorized锁膨胀升级过程是怎样的" class="router-link-active router-link-exact-active toc-link level3">synchorized锁膨胀升级过程是怎样的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#synchorized为什么不再使用偏向锁" class="router-link-active router-link-exact-active toc-link level3">synchorized为什么不再使用偏向锁？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#synchorized和lock锁的区别是什么" class="router-link-active router-link-exact-active toc-link level3">synchorized和Lock锁的区别是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#锁的分类" class="router-link-active router-link-exact-active toc-link level3">锁的分类</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是aqs" class="router-link-active router-link-exact-active toc-link level3">什么是AQS？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是cas原理" class="router-link-active router-link-exact-active toc-link level3">什么是CAS原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#原子类如何实现的cas" class="router-link-active router-link-exact-active toc-link level3">原子类如何实现的CAS？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#threadlocal的作用是什么-threadlocal是如何实现的" class="router-link-active router-link-exact-active toc-link level3">ThreadLocal的作用是什么？ThreadLocal是如何实现的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何创建线程池-有哪些参数-都有什么作用-实现原理" class="router-link-active router-link-exact-active toc-link level3">如何创建线程池？有哪些参数，都有什么作用(实现原理)？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何设定线程数" class="router-link-active router-link-exact-active toc-link level3">如何设定线程数？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池都有哪些任务拒绝策略" class="router-link-active router-link-exact-active toc-link level3">线程池都有哪些任务拒绝策略？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#工作中都用到过哪些线程池" class="router-link-active router-link-exact-active toc-link level3">工作中都用到过哪些线程池？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池的使用" class="router-link-active router-link-exact-active toc-link level3">线程池的使用</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池的状态转换" class="router-link-active router-link-exact-active toc-link level3">线程池的状态转换</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池是如何实现的" class="router-link-active router-link-exact-active toc-link level3">线程池是如何实现的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池如何做到核心线程复用" class="router-link-active router-link-exact-active toc-link level3">线程池如何做到核心线程复用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池如何做到核心线程不会被执行完毕" class="router-link-active router-link-exact-active toc-link level3">线程池如何做到核心线程不会被执行完毕？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java线程池分配线程按照密集型分有那几类" class="router-link-active router-link-exact-active toc-link level3">java线程池分配线程按照密集型分有那几类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#两种密集型如何分配线程数" class="router-link-active router-link-exact-active toc-link level3">两种密集型如何分配线程数？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#为何这么分配线程数" class="router-link-active router-link-exact-active toc-link level3">为何这么分配线程数？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#用过哪些juc并发工具类-都是什么作用" class="router-link-active router-link-exact-active toc-link level3">用过哪些JUC并发工具类，都是什么作用？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#是否了解future框架" class="router-link-active router-link-exact-active toc-link level3">是否了解Future框架？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何实现一个线程" class="router-link-active router-link-exact-active toc-link level3">如何实现一个线程？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#todo-多线程基础" class="router-link-active router-link-exact-active toc-link level3">todo 多线程基础</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是线程安全" class="router-link-active router-link-exact-active toc-link level3">什么是线程安全？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程安全的数据结构" class="router-link-active router-link-exact-active toc-link level3">线程安全的数据结构？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java高级特性" class="router-link-active router-link-exact-active toc-link level2">Java高级特性</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的泛型机制" class="router-link-active router-link-exact-active toc-link level3">什么是Java的泛型机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的注解机制" class="router-link-active router-link-exact-active toc-link level3">什么是Java的注解机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的反射机制" class="router-link-active router-link-exact-active toc-link level3">什么是Java的反射机制？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的spi机制" class="router-link-active router-link-exact-active toc-link level3">什么是Java的SPI机制？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java数据结构" class="router-link-active router-link-exact-active toc-link level2">Java数据结构</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#hashmap原理" class="router-link-active router-link-exact-active toc-link level3">HashMap原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#arraylist原理" class="router-link-active router-link-exact-active toc-link level3">ArrayList原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#linkedlist原理" class="router-link-active router-link-exact-active toc-link level3">LinkedList原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#linkedhashmap原理" class="router-link-active router-link-exact-active toc-link level3">LinkedHashMap原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#hashmap为什么不是线程安全的" class="router-link-active router-link-exact-active toc-link level3">HashMap为什么不是线程安全的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#concurrenthashmap如何实现线程安全的" class="router-link-active router-link-exact-active toc-link level3">ConcurrentHashMap如何实现线程安全的？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java-io特性" class="router-link-active router-link-exact-active toc-link level2">Java IO特性</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#javaio是什么" class="router-link-active router-link-exact-active toc-link level3">JavaIO是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何理解javaio的装饰者模式" class="router-link-active router-link-exact-active toc-link level3">如何理解JavaIO的装饰者模式？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的bio" class="router-link-active router-link-exact-active toc-link level3">什么是Java的BIO</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java-nio-请说一下java-nio的多路复用原理" class="router-link-active router-link-exact-active toc-link level3">什么是Java NIO？请说一下Java NIO的多路复用原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java-aio技术是什么" class="router-link-active router-link-exact-active toc-link level3">Java AIO技术是什么？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java新特性" class="router-link-active router-link-exact-active toc-link level2">Java新特性</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java-8-11的新特性" class="router-link-active router-link-exact-active toc-link level3">Java 8-11的新特性？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java-12-17的新特性" class="router-link-active router-link-exact-active toc-link level3">java 12-17的新特性？</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><div class="custom-container info"><p class="custom-container-title">相关信息</p><p>  面试题话术汇总，方便面试复习</p></div><nav class="table-of-contents"><ul><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#jvm原理" class="router-link-active router-link-exact-active">JVM原理</a><ul><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#请简单说一下类的加载过程" class="router-link-active router-link-exact-active">请简单说一下类的加载过程？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#jvm提供了哪些类加载器-类加载器如何初始化的" class="router-link-active router-link-exact-active">JVM提供了哪些类加载器？类加载器如何初始化的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何自定义类加载" class="router-link-active router-link-exact-active">如何自定义类加载？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是双亲委派机制" class="router-link-active router-link-exact-active">什么是双亲委派机制？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何打破双亲委派机制-tomcat是如何打破双亲委派机制的" class="router-link-active router-link-exact-active">如何打破双亲委派机制？Tomcat是如何打破双亲委派机制的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的spi机制-如何实现" class="router-link-active router-link-exact-active">什么是Java的SPI机制？如何实现？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是jvm的内存模型-都有哪几部分组成-各有什么作用" class="router-link-active router-link-exact-active">什么是JVM的内存模型？都有哪几部分组成？各有什么作用？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#堆内存如何划分的-数据在堆内存中如何流转的" class="router-link-active router-link-exact-active">堆内存如何划分的？数据在堆内存中如何流转的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java如何创建一个对象" class="router-link-active router-link-exact-active">Java如何创建一个对象？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java对象头的结构是什么样的" class="router-link-active router-link-exact-active">Java对象头的结构是什么样的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java对象在栈内如何分配的" class="router-link-active router-link-exact-active">Java对象在栈内如何分配的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java对象在eden区如何分配的" class="router-link-active router-link-exact-active">Java对象在Eden区如何分配的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#老年代都存放哪些对象" class="router-link-active router-link-exact-active">老年代都存放哪些对象？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java大对象在内存中如何分配" class="router-link-active router-link-exact-active">Java大对象在内存中如何分配？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#长期存活的对象存放在哪儿" class="router-link-active router-link-exact-active">长期存活的对象存放在哪儿？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是对象的动态年龄判断机制" class="router-link-active router-link-exact-active">什么是对象的动态年龄判断机制？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是老年代空间分配的担保机制" class="router-link-active router-link-exact-active">什么是老年代空间分配的担保机制？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#jvm提供了哪些引用类型" class="router-link-active router-link-exact-active">JVM提供了哪些引用类型？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何判断一个对象是否应该被回收" class="router-link-active router-link-exact-active">如何判断一个对象是否应该被回收？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#finalize-方法的作用是什么" class="router-link-active router-link-exact-active">finalize()方法的作用是什么？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何判断一个类是无用的类" class="router-link-active router-link-exact-active">如何判断一个类是无用的类？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#有哪些垃圾回收算法" class="router-link-active router-link-exact-active">有哪些垃圾回收算法？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#常用的垃圾回收器有哪些" class="router-link-active router-link-exact-active">常用的垃圾回收器有哪些？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何选择合适的垃圾回收器" class="router-link-active router-link-exact-active">如何选择合适的垃圾回收器？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#jvm调优" class="router-link-active router-link-exact-active">JVM调优</a><ul><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#平常都是怎么做jvm调优的-调优的思路" class="router-link-active router-link-exact-active">平常都是怎么做JVM调优的(调优的思路)？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如果发生cpu使用率偏高、内存偏高等具体的问题-调优的思路是什么" class="router-link-active router-link-exact-active">如果发生CPU使用率偏高、内存偏高等具体的问题，调优的思路是什么？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java并发" class="router-link-active router-link-exact-active">Java并发</a><ul><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#cpu的三层缓存架构" class="router-link-active router-link-exact-active">CPU的三层缓存架构？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是用户态-什么是内核态-操作系统如何管理内存" class="router-link-active router-link-exact-active">什么是用户态，什么是内核态？操作系统如何管理内存？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是jmm内存模型" class="router-link-active router-link-exact-active">什么是JMM内存模型？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#简述一下线程安全的三个特性" class="router-link-active router-link-exact-active">简述一下线程安全的三个特性？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#volatile关键字的作用是怎样的-如何实现的" class="router-link-active router-link-exact-active">volatile关键字的作用是怎样的？如何实现的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#简述一下final关键字和不变性原理" class="router-link-active router-link-exact-active">简述一下final关键字和不变性原理？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#synchronized关键字的作用是什么" class="router-link-active router-link-exact-active">synchronized关键字的作用是什么？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#synchorized锁膨胀升级过程是怎样的" class="router-link-active router-link-exact-active">synchorized锁膨胀升级过程是怎样的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#synchorized为什么不再使用偏向锁" class="router-link-active router-link-exact-active">synchorized为什么不再使用偏向锁？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#synchorized和lock锁的区别是什么" class="router-link-active router-link-exact-active">synchorized和Lock锁的区别是什么？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#锁的分类" class="router-link-active router-link-exact-active">锁的分类</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是aqs" class="router-link-active router-link-exact-active">什么是AQS？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是cas原理" class="router-link-active router-link-exact-active">什么是CAS原理？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#原子类如何实现的cas" class="router-link-active router-link-exact-active">原子类如何实现的CAS？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#threadlocal的作用是什么-threadlocal是如何实现的" class="router-link-active router-link-exact-active">ThreadLocal的作用是什么？ThreadLocal是如何实现的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何创建线程池-有哪些参数-都有什么作用-实现原理" class="router-link-active router-link-exact-active">如何创建线程池？有哪些参数，都有什么作用(实现原理)？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何设定线程数" class="router-link-active router-link-exact-active">如何设定线程数？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池都有哪些任务拒绝策略" class="router-link-active router-link-exact-active">线程池都有哪些任务拒绝策略？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#工作中都用到过哪些线程池" class="router-link-active router-link-exact-active">工作中都用到过哪些线程池？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池的使用" class="router-link-active router-link-exact-active">线程池的使用</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池的状态转换" class="router-link-active router-link-exact-active">线程池的状态转换</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池是如何实现的" class="router-link-active router-link-exact-active">线程池是如何实现的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池如何做到核心线程复用" class="router-link-active router-link-exact-active">线程池如何做到核心线程复用？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程池如何做到核心线程不会被执行完毕" class="router-link-active router-link-exact-active">线程池如何做到核心线程不会被执行完毕？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java线程池分配线程按照密集型分有那几类" class="router-link-active router-link-exact-active">java线程池分配线程按照密集型分有那几类？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#两种密集型如何分配线程数" class="router-link-active router-link-exact-active">两种密集型如何分配线程数？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#为何这么分配线程数" class="router-link-active router-link-exact-active">为何这么分配线程数？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#用过哪些juc并发工具类-都是什么作用" class="router-link-active router-link-exact-active">用过哪些JUC并发工具类，都是什么作用？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#是否了解future框架" class="router-link-active router-link-exact-active">是否了解Future框架？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何实现一个线程" class="router-link-active router-link-exact-active">如何实现一个线程？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#todo-多线程基础" class="router-link-active router-link-exact-active">todo 多线程基础</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是线程安全" class="router-link-active router-link-exact-active">什么是线程安全？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#线程安全的数据结构" class="router-link-active router-link-exact-active">线程安全的数据结构？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java高级特性" class="router-link-active router-link-exact-active">Java高级特性</a><ul><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的泛型机制" class="router-link-active router-link-exact-active">什么是Java的泛型机制？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的注解机制" class="router-link-active router-link-exact-active">什么是Java的注解机制？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的反射机制" class="router-link-active router-link-exact-active">什么是Java的反射机制？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的spi机制" class="router-link-active router-link-exact-active">什么是Java的SPI机制？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java数据结构" class="router-link-active router-link-exact-active">Java数据结构</a><ul><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#hashmap原理" class="router-link-active router-link-exact-active">HashMap原理？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#arraylist原理" class="router-link-active router-link-exact-active">ArrayList原理？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#linkedlist原理" class="router-link-active router-link-exact-active">LinkedList原理？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#linkedhashmap原理" class="router-link-active router-link-exact-active">LinkedHashMap原理？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#hashmap为什么不是线程安全的" class="router-link-active router-link-exact-active">HashMap为什么不是线程安全的？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#concurrenthashmap如何实现线程安全的" class="router-link-active router-link-exact-active">ConcurrentHashMap如何实现线程安全的？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java-io特性" class="router-link-active router-link-exact-active">Java IO特性</a><ul><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#javaio是什么" class="router-link-active router-link-exact-active">JavaIO是什么？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何理解javaio的装饰者模式" class="router-link-active router-link-exact-active">如何理解JavaIO的装饰者模式？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java的bio" class="router-link-active router-link-exact-active">什么是Java的BIO</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是java-nio-请说一下java-nio的多路复用原理" class="router-link-active router-link-exact-active">什么是Java NIO？请说一下Java NIO的多路复用原理？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java-aio技术是什么" class="router-link-active router-link-exact-active">Java AIO技术是什么？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java新特性" class="router-link-active router-link-exact-active">Java新特性</a><ul><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java-8-11的新特性" class="router-link-active router-link-exact-active">Java 8-11的新特性？</a></li><li><a aria-current="page" href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html#java-12-17的新特性" class="router-link-active router-link-exact-active">java 12-17的新特性？</a></li></ul></li></ul></nav><hr><h2 id="jvm原理" tabindex="-1"><a class="header-anchor" href="#jvm原理" aria-hidden="true">#</a> JVM原理</h2><h3 id="请简单说一下类的加载过程" tabindex="-1"><a class="header-anchor" href="#请简单说一下类的加载过程" aria-hidden="true">#</a> 请简单说一下类的加载过程？</h3><p>  类加载主要分为加载、验证、准备、解析和初始化阶段。</p><ol><li>在加载之前，java文件会被编译打包成class文件，此时大部分final修饰的静态常量分配内存，放入方法区的常量池，同时进行泛型擦除。</li><li>加载：JVM使用类加载器加载类，读入字节码文件，生成对象存入堆内存。</li><li>验证：验证字节码、文件格式、元数据、符号引用等。</li><li>准备：静态变量在方法区分配内存，静态变量赋默认值。</li><li>解析：执行静态链接，即将常量池中的符号引用变为直接引用。</li><li>初始化：静态变量赋初始值，执行静态代码块。注意，只有主动使用类时，才会执行初始化，也就是以下几种情况： <ul><li>new一个对象</li><li>访问非final修饰的静态变量或者执行静态方法</li><li>反射调用</li><li>main()方法启动时初始化</li><li>default方法要在接口实现实例化前初始化</li><li>父类没有初始化需要先初始化父类</li></ul></li><li>初始化后就可以使用对象了，类(class)被加载到方法区后保存的信息有以下： <ul><li>运行时常量池</li><li>类型信息</li><li>字段信息</li><li>方法信息</li><li>类加载器的引用</li><li>Class对象的引用</li></ul></li><li>对象使用完成后会被回收，其中BootstrapClassLoader、ExtClassLoader、AppClassLoader加载的类不会被卸载，只会将实例化后的对象GC，自定义加载器加载的类在使用完成后，类信息也会被卸载。</li></ol><h3 id="jvm提供了哪些类加载器-类加载器如何初始化的" tabindex="-1"><a class="header-anchor" href="#jvm提供了哪些类加载器-类加载器如何初始化的" aria-hidden="true">#</a> JVM提供了哪些类加载器？类加载器如何初始化的？</h3><p>  JVM提供了三种类加载器：BootstrapClassLoader、ExtClassLoader、AppClassLoader。</p><ul><li>BootstrapClassLoader：加载JAVA_HOME/lib下的类</li><li>ExtClassLoader：加载JAVA_HOME/ext/lib下的类</li><li>AppClassLoader：加载CLASS_PATH下的类</li></ul><h3 id="如何自定义类加载" tabindex="-1"><a class="header-anchor" href="#如何自定义类加载" aria-hidden="true">#</a> 如何自定义类加载？</h3><ol><li>继承ClassLoader。</li><li>重写findClass()方法并调用definiteClass()方法实现类加载过程。</li><li>重写loadClass()方法实现向上委托机制。</li></ol><h3 id="什么是双亲委派机制" tabindex="-1"><a class="header-anchor" href="#什么是双亲委派机制" aria-hidden="true">#</a> 什么是双亲委派机制？</h3><p>  所谓的双亲委派机制，就是JVM避免类被重复加载和防止核心类库被外部类篡改的一种机制：</p><ol><li>当我们有自定义类加载器时，在加载类时，首先判断是否已经加载过，如果加载过则直接返回；否则会调用loadClass()方法调用上一级的类加载器，也就是AppClassLoader。</li><li>AppClassLoader也会首先检查自己的范围内是否加载了该类，如果加载过直接返回；否则调用loadClass()方法调用上一级类加载器，也就是ExtClassLoader。</li><li>ExtClassLoader同样先检查自己的范围内是否加载了该类，如果加载了直接返回；否则调用loadClass()方法调用上一级的类加载器BootstrapClassLoader。</li><li>BootstrapClassLoader检查是否已经加载了该类，如果加载了，直接返回；否则判断是否是属于该类加载器的加载范围，如果属于范围内的类，则进行加载，否则调用findClass()委托下一级进行加载。</li><li>ExtClassLoader判断该类是否是自己的加载范围内的类，如果是进行加载；否则调用findClass委托下一级类加载器进行加载。</li><li>AppClassLoader判断该类是否属于自己的加载范围，如果是则进行加载；否则调用findClass()委托下一级类加载器进行加载。</li><li>自定义类加载器加载类。</li></ol><h3 id="如何打破双亲委派机制-tomcat是如何打破双亲委派机制的" tabindex="-1"><a class="header-anchor" href="#如何打破双亲委派机制-tomcat是如何打破双亲委派机制的" aria-hidden="true">#</a> 如何打破双亲委派机制？Tomcat是如何打破双亲委派机制的？</h3><p>  通过重写loadClass()方法直接加载字节码文件，而不是委托parent进行加载，就可以打破双亲委派机制。</p><p>  Tomcat每一个WebApp都应该是隔离的，因此不能混淆，所以每个WebApp之间的类加载器是打破双亲委派的，只加载自己容器的类。具体的实现就是Tomcat容器自己有所需要的公共类库，提供了一个类加载器用来加载，WebApp之间共享。每个WebApp又有自己独有的类加载器，打破了双亲委派，只加载自己WebApp下所使用到的类。</p><h3 id="什么是java的spi机制-如何实现" tabindex="-1"><a class="header-anchor" href="#什么是java的spi机制-如何实现" aria-hidden="true">#</a> 什么是Java的SPI机制？如何实现？</h3><p>  Java的SPI机制是一种服务发现机制，可以通过读取ClassPath下META-INFO/services文件，自动加载接口的实现类，每次会把所有配置的类都加载上，比较消耗资源。</p><p>  Java的SPI机制的实现，依赖于ServiceLoader，ServiceLoader通过一个懒加载的扫描器来扫描META-INFO/services下的文件名并且转换为类的全限定名，然后通过反射机制加载类。</p><h3 id="什么是jvm的内存模型-都有哪几部分组成-各有什么作用" tabindex="-1"><a class="header-anchor" href="#什么是jvm的内存模型-都有哪几部分组成-各有什么作用" aria-hidden="true">#</a> 什么是JVM的内存模型？都有哪几部分组成？各有什么作用？</h3><p>  Java虚拟机由类加载子系统、运行时数据区和字节码执行引擎组成。其中类加载子系统负责进行编译和将字节码文件加载为类，加载后的class文件被存储到运行时数据区，字节码执行引擎执行运行时数据区的数据。</p><p>  其中运行时数据区的内存划分就是JVM的内存模型，是一种逻辑划分，分为堆、栈、方法区、本地方法栈和程序计数器。</p><ul><li>堆：线程之间共享，用于存放对象，分为年轻代和老年代，一般情况下年轻代和老年代占比为1:2，年轻代又划分为Eden区和Survivor区，Eden区和Survivor区划分比例一般是8:1:1。</li><li>方法栈和本地方法栈：线程独有，以方法为栈帧，一个方法执行则代表一个栈帧入栈，一个方法执行结束则代表一个栈帧出栈。本地方法栈与方法栈作用一样，区别是一个运行本地方法。栈帧内存放方法相关信息，包括： <ul><li>局部变量表：存放方法的局部变量，其中引用变量存放指针，引用自堆。</li><li>操作数栈：存放逻辑运算的操作数。</li><li>动态链接：动态链接的作用是把方法的符号引用变成直接引用，指向方法区存放的方法。</li><li>方法出口：方法执行结束后应该返回的位置。</li></ul></li><li>程序计数器：线程独有，每个方法栈有一个程序计数器，存放行号，因此又叫行号计数器，用于记录当前线程执行代码的位置。</li><li>方法区：线程共享，存放类的元信息、常量、静态变量、即时编译后的代码缓存等。</li></ul><h3 id="堆内存如何划分的-数据在堆内存中如何流转的" tabindex="-1"><a class="header-anchor" href="#堆内存如何划分的-数据在堆内存中如何流转的" aria-hidden="true">#</a> 堆内存如何划分的？数据在堆内存中如何流转的？</h3><p>  JVM采用分代收集的思想管理内存，不同的垃圾回收器对堆内存的具体物理划分是不一样的，但是可以抽象为一个比较简单的逻辑划分：年轻代和老年代，年轻代又分为Eden区和Survivor区。其中默认年轻代和老年代比例是1:2，Eden区和S区比例是8:1:1。</p><p>  Jvm中对象在堆内存中的流转过程大致如下：</p><ol><li>新的对象进入Eden区。</li><li>Eden区满后，minor gc，根据GC Root找到不需要进行垃圾回收的对象，放入s0区，分代年龄+1，其他对象gc掉。</li><li>当Eden区再次放满后，再次触发minor GC，s0的区域也会minor GC，Eden和s0区不需要被回收的对象放入s1区，同时分代年龄+1，其他对象回收掉。</li><li>重复上述过程，直到分代年龄到达默认15或者设定的阈值，挪到老年代，其中大对象直接存入老年代。</li><li>当老年代满后，触发full gc，回收整个方法区、堆。</li><li>如果full gc后老年代仍然是满的，触发oom。</li></ol><p>  其中full gc是一个stop the world的过程，因此十分消耗资源。另外，Spring的Bean、缓存、常量引用这种对象一般都是最终会长时间存在于老年代。</p><h3 id="java如何创建一个对象" tabindex="-1"><a class="header-anchor" href="#java如何创建一个对象" aria-hidden="true">#</a> Java如何创建一个对象？</h3><ol><li>类加载检查：new关键字实例化一个对象时，检查指令参数是否能在方法区定位到一个类的符号引用，并且检查这个符号引用是否已经被加载、解析和初始化，如果没有则先执行类的加载过程。</li><li>类加载：详见类加载的5个步骤。</li><li>分配内存：类加载后，为新的对象分配内存。对象所需要的内存在类加载完成后就可以确定，这里涉及到两个问题，内存划分的方法和并发划分内存的问题： <ul><li>内存划分方法： <ul><li>默认指针碰撞，如果java堆是规整的，那么会将Java堆内存分为两部分，一部分是分配过的，一部分是未分配的，指针指向分配过的末尾，每次分配内存指针挪动对应距离即可。</li><li>空闲列表：如果内存不规整，那么虚拟机就需要维护一个列表，记录哪些内存块可以使用，分配内存时将符合条件的内存分配给对象并且更新空闲列表。</li></ul></li><li>并发划分内存： <ul><li>CAS：虚拟机采用CAS加上重试机制保证内存更新的原子性，以此来进行同步处理。</li><li>本地线程分配缓冲区(TLAB)：为每个线程分配一定的空间，按照线程执行内存分配动作。</li></ul></li></ul></li><li>初始化：初始化主要是完成一些默认操作，如给属性付默认值。</li><li>设置对象头：给对象的对象头设置对应属性。</li><li>执行对象的init方法，即按照用户的指定进行初始化。</li></ol><h3 id="java对象头的结构是什么样的" tabindex="-1"><a class="header-anchor" href="#java对象头的结构是什么样的" aria-hidden="true">#</a> Java对象头的结构是什么样的？</h3><p>  对象在内存中存储分为三部分：对象头、实例数据和对齐填充。其中实例数据就是对象实例包含的相关数据信息，对齐填充是需要把对象大小填充为8的倍数，以便于CPU高效执行。</p><p>  对象头分为两部分，一部分存储对象的运行时信息，如GC年龄分代、锁状态、线程持有的锁、偏向线程ID等等。</p><p>  另一部分是类型指针，指向方法区中类的元数据信息。</p><p>  由于一个Java对象指针是35位，如果不进行压缩的话，实际存储需要64位，寻址大小就不支持小内存寻址，而且会增加GC压力，因此JVM会开启指针压缩，将35位指针压缩为32位，这样就支持32G以下的内存，4G内存以下直接砍掉高位32位、32G以内4G以上使用压缩指针，32G以上使用64位的指针，因此一般堆内存不要超过32G。</p><h3 id="java对象在栈内如何分配的" tabindex="-1"><a class="header-anchor" href="#java对象在栈内如何分配的" aria-hidden="true">#</a> Java对象在栈内如何分配的？</h3><p>  大部分的对象是在堆内存中分配的，但是为了减少临时对象在堆内的分配数量，JVM会通过逃逸分析分析对象会不会被外部方法访问到，如果不会被外部方法访问到，那么会进行标量替换，将对象的属性替换为方法的内部属性，在栈分配空间，生命周期随着方法的执行周期。</p><p>  其中逃逸分析和标量替换都是默认开启，可以通过启动参数控制开启或者关闭。</p><h3 id="java对象在eden区如何分配的" tabindex="-1"><a class="header-anchor" href="#java对象在eden区如何分配的" aria-hidden="true">#</a> Java对象在Eden区如何分配的？</h3><p>  大多数情况下，新的对象都被分配在Eden区，当Eden区没有空间可供分配时，触发young GC或者Minor GC。这里需要区分一下GC的类型：</p><ul><li>Minor GC/Young GC：发生在新生代，比较频繁，回收速度也比较快。</li><li>Full GC/Major GC：发生在堆和方法区的所有区域的垃圾对象，由老年代满载触发，回收范围大，效率比Minor GC慢非常多。</li></ul><p>  大量的对象被存放在Eden区，Eden区存放满了后触发Minor GC，大概99%的对象都会被回收，剩余的存活对象被挪到s区，并且增加分代年龄，当下一次Eden区满后，Minor GC会同时回收Eden区和s区，并把存活的对象挪到另一片s区。</p><p>  Eden区和Survivor区的分配比例默认是8:1:1，分配原则是尽可能使得Eden区大，S区够用即可。可以通过启动参数开启自动动态调节比例(默认开启)，也可以通过参数控制是否打印GC日志(默认打印)。</p><h3 id="老年代都存放哪些对象" tabindex="-1"><a class="header-anchor" href="#老年代都存放哪些对象" aria-hidden="true">#</a> 老年代都存放哪些对象？</h3><p>  老年代存放大对象和长期存活的对象，详见上述两个问题。</p><p>  大对象的特点是需要大量连续的内存空间，可以通过JVM的启动参数设定大对象的大小。如果大对象超过设定的参数大小，会直接进入老年代。</p><p>  之所以大对象会直接进入老年代，是为了避免大对象的复制操作会非常降低效率。</p><p>  对象的分代年龄是通过对象头的对象年龄计数器来累加的，对象在正常的gc过后，如果被存留，分代年龄会被累加1，当分代年龄达到一个阈值(默认15)，会被老年代收容，进而减少被Minor GC的频率，减少复制次数。阈值可以通过参数设置。</p><h3 id="java大对象在内存中如何分配" tabindex="-1"><a class="header-anchor" href="#java大对象在内存中如何分配" aria-hidden="true">#</a> Java大对象在内存中如何分配？</h3><p>  大对象的特点是需要大量连续的内存空间，可以通过JVM的启动参数设定大对象的大小。如果大对象超过设定的参数大小，会直接进入老年代。</p><p>  之所以大对象会直接进入老年代，是为了避免大对象的复制操作会非常降低效率。</p><h3 id="长期存活的对象存放在哪儿" tabindex="-1"><a class="header-anchor" href="#长期存活的对象存放在哪儿" aria-hidden="true">#</a> 长期存活的对象存放在哪儿？</h3><p>  对象的分代年龄是通过对象头的对象年龄计数器来累加的，对象在正常的gc过后，如果被存留，分代年龄会被累加1，当分代年龄达到一个阈值(默认15)，会被老年代收容，进而减少被Minor GC的频率，减少复制次数。阈值可以通过参数设置。</p><h3 id="什么是对象的动态年龄判断机制" tabindex="-1"><a class="header-anchor" href="#什么是对象的动态年龄判断机制" aria-hidden="true">#</a> 什么是对象的动态年龄判断机制？</h3><p>  当S区的一批对象大于当前空间的一个比例(默认50%，可以通过启动参数设置)，那么大于这批对象年龄中最大值的对象在下次GC时直接进入老年代，不用判断分代年龄阈值。对象的动态年龄判断一般发生在Minor GC时。</p><p>  动态年龄判断是一种空间换时间的概念，但是会造成一个问题，如果很多对象的生存时间大于一次MinorGC的时间，每次都能大于空间比例阈值，那么就会造成很多的对象涌入老年代从而引发频繁Full GC，这时就需要通过更改动态年龄空间比例来避免。</p><h3 id="什么是老年代空间分配的担保机制" tabindex="-1"><a class="header-anchor" href="#什么是老年代空间分配的担保机制" aria-hidden="true">#</a> 什么是老年代空间分配的担保机制？</h3><p>  Minor GC时会计算老年代的空间，如果这个空间小于年轻代的所有对象(包括未被回收的对象)的空间之和，则会判断老年代的空间是否大于之前每一次进入老年代的的对象的平均大小，如果小于，则会直接触发Full GC。</p><p>  这也是容易频繁触发Full GC的一个原因之一，需要通过调整空间分配比例来调优。</p><h3 id="jvm提供了哪些引用类型" tabindex="-1"><a class="header-anchor" href="#jvm提供了哪些引用类型" aria-hidden="true">#</a> JVM提供了哪些引用类型？</h3><ul><li>强引用：平常我们声明的对象引用都是强引用。</li><li>软引用：通过SoftRefrence声明，Full GC后如果没有可以释放的空间，会释放软引用。</li><li>弱引用：GC会直接回收。</li><li>虚引用：GC会直接回收。</li></ul><h3 id="如何判断一个对象是否应该被回收" tabindex="-1"><a class="header-anchor" href="#如何判断一个对象是否应该被回收" aria-hidden="true">#</a> 如何判断一个对象是否应该被回收？</h3><p>  JVM判断一个对象是否应该被回收是通过可达性分析算法和finalize()方法完成的。</p><p>  可达性分析算法是将GC Roots作为对象的起点，从这些节点开始向下搜索，可以找到的对象都是非垃圾对象，其实也就是GC Roots一级级引用的对象。其中可以作为GC Roots的对象有：线程栈的本地变量、静态变量、本地方法栈的变量等。</p><p>  finalize()方法用于判定对象的最终存活，不在GC Roots树上的对象也不是非要垃圾回收，它还有一次机会，就是在finalize()方法中再次被引用，使其与GC Roots树上的对象再次关联。但是只能有一次机会，当这次执行完毕后，再次出发GC，即便方法中做了关联也会被回收。</p><h3 id="finalize-方法的作用是什么" tabindex="-1"><a class="header-anchor" href="#finalize-方法的作用是什么" aria-hidden="true">#</a> finalize()方法的作用是什么？</h3><p>  finalize()方法用于判定对象的最终存活，不在GC Roots树上的对象也不是非要垃圾回收，它还有一次机会，就是在finalize()方法中再次被引用，使其与GC Roots树上的对象再次关联。但是只能有一次机会，当这次执行完毕后，再次出发GC，即便方法中做了关联也会被回收。</p><h3 id="如何判断一个类是无用的类" tabindex="-1"><a class="header-anchor" href="#如何判断一个类是无用的类" aria-hidden="true">#</a> 如何判断一个类是无用的类？</h3><p>  类的元信息主要存放在方法区中，方法区也负责类的回收，判定方式如下：</p><ul><li>该类的所有对象实例已经被回收</li><li>加载该类的类加载器对象也已经被回收</li><li>该类的Class对象没有任何地方被引用，也就是无法通过反射生成类。</li></ul><h3 id="有哪些垃圾回收算法" tabindex="-1"><a class="header-anchor" href="#有哪些垃圾回收算法" aria-hidden="true">#</a> 有哪些垃圾回收算法？</h3><ul><li>复制算法：将内存分为两个区域，使用一片存放对象，当垃圾回收时，清理掉需要回收的对象，将存活的对象放在另一边。</li><li>标记-清除算法：分为两个阶段，标记和清除。标记阶段用于通过GC roots标记所有存活对象；清除阶段清除所有未被标记的对象。会有两个问题，标记阶段如果需要被清除的对象非常多，会有效率问题；清除后的内存空间不连续。</li><li>标记-整理算法：标记阶段与标记清除算法一致，通过GC Roots标记存活对象；标记完成后将所有存活对象移动到内存的一端，然后统一清除存活对象之后的空间。</li></ul><h3 id="常用的垃圾回收器有哪些" tabindex="-1"><a class="header-anchor" href="#常用的垃圾回收器有哪些" aria-hidden="true">#</a> 常用的垃圾回收器有哪些？</h3><p>  现在比较常用的是小内存情况下的CMS、平时常用的G1、新的支持大内存的ZGC。</p><p>  <strong>首先是CMS垃圾回收器</strong>，采用分代收集理论，其执行过程分为以下几个阶段：</p><ol><li>初始标记：STW，标记GC Roots和其可以直接引用到的对象</li><li>并发标记：并发标记GC Roots树，进行标记</li><li>重新标记：STW，修正并发标记阶段动态变化的对象标记</li><li>并发清理：对没有被标记的对象进行清理</li><li>并发重置：重置本次GC中的标记</li></ol><p>  CMS垃圾回收器采用标记-清除算法，标记过程采用的三色标记法，其原理是将对象分为黑色、灰色和白色。黑色代表已经被垃圾回收器扫描过，可达性分析是可达的。灰色表示已经被垃圾回收器扫描过，但是其树的下层还存在没有被扫描的对象。白色表示没有被扫描过。如果扫描结束后对象仍然是白色，那么说明该对象不可达，需要被回收。</p><p>  其中在重新标记阶段，为了防止漏标，CMS采用的是增量更新的策略，即将黑色的对象作为GC Roots重新进行扫描，那么动态更新时插入到黑色的或者灰色的引用就会被再次扫描到。增量更新和原始快照都是通过读写屏障完成，读写屏障即在完成内存的读写操作的前后，插入一步操作，类似于AOP。</p><p>  CMS垃圾回收器会争抢业务线程的资源，并且不能处理浮动垃圾，只能下次处理浮动垃圾，标记清除算法会产生大量的内存碎片(可以通过参数设置清理)。</p><p>  CMS相关的调优参数有老年代触发FullGC的比例、GC的线程数、指定整理压缩空间的间隔等等。</p><p>  CMS是传统的分代理论实现的垃圾回收器，会存在跨代引用的问题，CMS采用的是记忆集数据结构，避免把老年代纳入GC范围，因此只要通过记忆集查找是否有跨代引用即可。</p><p>  <strong>G1垃圾回收器</strong>的内存划分与传统的垃圾回收器不同，G1虽然也沿用了跨代的理念，但是只做了逻辑划分，实际的物理划分是将内存划分为大小相等的独立区域(Region)，JVM最多可以划分2048个Region，并且可以通过参数指定Region。</p><p>  G1依旧存在分代的理念，但是分代区域不再连续，而是指定Region的分代。默认年轻代初始比例5%(可以通过参数调整)，JVM在运行过程中会动态的增加年轻代的比例，最终占比不会超过60%(也可以调整)，Eden区和s区比例依旧是8:1:1。</p><p>  其对象的流转过程不变，依旧符合数据在堆内存中的流转过程，不同的是大对象的存储规则：G1针对大对象会专门的分配Humorous区域，对于对象大小大于Region的50%的对象即判定为大对象，直接存入大对象块，超过Region大小的对象则会跨Region连续存放。</p><p>  G1垃圾回收处理器的执行过程分为以下几个阶段：</p><ol><li>初始标记：STW，标记GC Roots和能够直接引用的对象</li><li>并发标记：并发标记GC Roots树</li><li>最终标记：STW，修正动态变化的对象状态</li><li>筛选回收：首先对每个Region的回收价值进行排序，根据用户设定的GC停顿期望时间定制回收计划，然后利用复制算法进行回收，这样就不会产生内存碎片。</li></ol><p>  G1垃圾处理器的GC阶段也与传统的垃圾回收器不同：</p><ul><li>YoungGC：不再是Eden满了才回收，而是计算回收Eden时间，如果回收时间远小于期望，则会增加Eden区的Region数量。</li><li>Mixed GC：G1独有的回收阶段，当老年代占比达到预期进行，回收所有的Young、Old、大对象，也是采用复制算法，只是回收范围更大。</li><li>Full GC：Mixed GC后发现空间依然不足执行，采用单线程的标记-压缩-整理算法，很耗时。</li></ul><p>  G1垃圾回收处理器的特点是：</p><ul><li>并发执行能力强，本身就是给多核大内存服务器用的，而且执行阶段允许并发执行。</li><li>分代概念：仍然保有分代理念。</li><li>空间整理：整体采用标记整理、局部采用复制算法，空间连续。</li><li>可停顿的预测：可以指定GC停顿间隔，减小对系统的影响，一般指定100-300ms。</li></ul><p>  G1垃圾回收器可以调优的参数：执行GC的并发线程数、指定分区大小、各个区的空间比例、期望gc停顿时间等等。</p><p>  <strong>ZGC是jdk11引入的一款可以处理大内存的垃圾回收器</strong>，ZGC不再采用分代收集原理，但是沿用了Region的概念，将内存划分为不同大小的Region，使用读写屏障、颜色指针技术实现可以并发的标记整理算法。</p><ul><li>小型Region：2M，存放小于256k的对象</li><li>中型Region：32M，存放大于256K小于4MB的对象</li><li>大型Region：容量动态化，但必须是2M的倍数，存放4M以上的大对象。大型Region的大小可能要比中型的小，实际看对象的大小。大型Region不会被ZGC重新分配。</li></ul><p>  ZGC的执行过程：</p><ol><li>并发标记：遍历对象图做并发标记，更新颜色指针。</li><li>并发预备重分配：会根据并发标记生成一个重分配集，重分配集记录Region上的存活对象。</li><li>并发重分配：将重分配集上存活的对象复制到新的Region，并且配置一个转发表，映射对象在新旧Region上的映射关系。此时如果引用了某个不需要被清理的对象，实际上是指向了重分配集，然后重分配集通过转发表映射了一个新的引用地址。</li><li>并发重映射：将重分配集上的旧引用剔除，更新为新的引用，这个过程可以在下次的并发标记的过程中完成。</li></ol><p>  ZGC最大的问题是浮动垃圾，ZGC没有分代概念。ZGC的触发时机总共有4个：</p><ul><li>定时触发：默认不适用，可以配置。</li><li>预热触发：最多三次，堆内存使用率达到10%、20%、30%时触发，统计GC时间为其他GC机制进行辅助。</li><li>分配速率触发：基于正态分布计算内存的分配速率，在内存耗尽之前触发。</li><li>主动触发：默认开启，判断内存距离上次GC后的增长量是否达到10%或者与上次GC的时间间隔比较，超过触发。</li></ul><h3 id="如何选择合适的垃圾回收器" tabindex="-1"><a class="header-anchor" href="#如何选择合适的垃圾回收器" aria-hidden="true">#</a> 如何选择合适的垃圾回收器？</h3><ul><li>优先调整堆大小让JVM自行选择</li><li>8G以内的小服务用CMS即可</li><li>一般的服务使用G1即可</li><li>几百G以上的大内存使用ZGC，更新JVM版本</li></ul><h2 id="jvm调优" tabindex="-1"><a class="header-anchor" href="#jvm调优" aria-hidden="true">#</a> JVM调优</h2><h3 id="平常都是怎么做jvm调优的-调优的思路" tabindex="-1"><a class="header-anchor" href="#平常都是怎么做jvm调优的-调优的思路" aria-hidden="true">#</a> 平常都是怎么做JVM调优的(调优的思路)？</h3><p>  JVM的调优一般指的是内存优化和垃圾回收器的优化。</p><p>  内存优化的思路是通过合理分配堆内存，使得朝生夕死的对象能都在年轻代不进入老年代，减少Full GC带来的影响，并且通过预估和计算对象内存的峰值防止OOM。</p><p>  内存是否需要优化可以通过对JVM和系统的监控完成，JVM提供了JvisualVM这种可视化工具来监控指标，生产环境下一般不允许。也可以使用命令行进行监控，常用的命令有：</p><ul><li>JPS：Java程序进程号</li><li>Jmap：查看实例的内存信息、堆的配置和使用状况、内存快照</li><li>jstack：重要，查看死锁、CPU使用率高的线程堆栈、</li><li>jstat：重要，查看堆内存各部分的使用量、类加载数量、堆分代内存的统计、垃圾回收的统计</li></ul><p>  内存优化的基本步骤一般是通过jstat间隔执行，查看年轻代对象的增长速率--&gt;推算YGC的执行时间--&gt;观测老年代的增长速率--&gt;观测FullGC的频率和耗时--&gt;进行优化。</p><p>  垃圾回收的优化还可以通过打印gc日志。</p><h3 id="如果发生cpu使用率偏高、内存偏高等具体的问题-调优的思路是什么" tabindex="-1"><a class="header-anchor" href="#如果发生cpu使用率偏高、内存偏高等具体的问题-调优的思路是什么" aria-hidden="true">#</a> 如果发生CPU使用率偏高、内存偏高等具体的问题，调优的思路是什么？</h3><p>  CPU使用率偏高，一般首先考虑死循环、频繁GC、上下文切换频繁。一般思路是通过检查top命令确定CPU使用情况，然后打印jstack堆栈和GC日志，进而确定问题原因。</p><p>  内存使用率偏高，没有OOM，可以导出Jmap的堆栈信息，查看具体的哪些实例占用偏高。</p><p>  如果内存使用出现OOM，一般从这几个角度考虑：</p><ul><li>本身内存分配和预估是否充足</li><li>从数据库或者其他地方一次性获取数据量过大</li><li>程序内短时间循环产生很多的重复对象</li></ul><h2 id="java并发" tabindex="-1"><a class="header-anchor" href="#java并发" aria-hidden="true">#</a> Java并发</h2><h3 id="cpu的三层缓存架构" tabindex="-1"><a class="header-anchor" href="#cpu的三层缓存架构" aria-hidden="true">#</a> CPU的三层缓存架构？</h3><p>  主流的CPU架构一般是采用三层缓存架构，多核CPU一般每一个核心称为一个物理核，每一个物理核有两个逻辑核、一个一级缓存和一个二级缓存组成，不同的物理核共享一个三级缓存。多CPU架构中，不同的CPU核心通过总线交互，共享内存。当一个线程运行在一个CPU上，又被调度到另一个CPU上时，就会发生上下文切换。</p><h3 id="什么是用户态-什么是内核态-操作系统如何管理内存" tabindex="-1"><a class="header-anchor" href="#什么是用户态-什么是内核态-操作系统如何管理内存" aria-hidden="true">#</a> 什么是用户态，什么是内核态？操作系统如何管理内存？</h3><p>  操作系统分为用户空间和内核空间两个概念，目的是为了程序运行的稳定和隔离。用户的线程只能运行在用户空间，系统的调用只能在内核空间。因此一个线程其实有两个堆栈：用户堆栈和内核堆栈。</p><ul><li>内核线程：由系统内核管理，使用内核堆栈保存线程信息和线程上下文信息，线程运行在内核态(权限级别不同，运行空间不同)。</li><li>用户线程：用户实现和管理，线程阻塞引起进程阻塞，线程运行在用户态(权限级别不同，运行空间不同)。</li></ul><p>  当一个用户线程想要调用系统函数库，那么就需要从用户态切换到内核态。</p><h3 id="什么是jmm内存模型" tabindex="-1"><a class="header-anchor" href="#什么是jmm内存模型" aria-hidden="true">#</a> 什么是JMM内存模型？</h3><p>  JMM的内存模型是基于CPU的三层缓存架构，在逻辑上，每一个线程有一个工作内存，工作内存与线程直接交互，存放共享变量的副本。所有的线程共享一个主内存，JMM控制线程的工作内存与主内存的交互。</p><p>  JMM对主内存和工作内存的数据同步通过八个原子性操作完成：</p><ol><li>lock(锁定)：将主内存的共享变量锁定为线程独占</li><li>read(读入)：将独占的共享变量读入线程的工作内存</li><li>load(载入)：将read读入的变量放入工作内存的共享变量副本</li><li>use(使用)：将共享变量副本传输给执行引擎使用</li><li>assign(复制)：执行引擎给共享变量副本复制</li><li>store(存储):工作内存将共享变量传输到主内存</li><li>write(写入)：将工作内存传输的共享变量副本值写入到共享变量</li><li>unlock(解锁)：将主内存内的共享变量解除线程独占。</li></ol><p>  在同步时，有以下的规则：</p><ul><li>不允许任何变量在没有assign，就同步回主内存中</li><li>任何变量必须由主内存中诞生，也就是说同步过程必须有read和load</li><li>一个变量同一时间只能被一个线程lock</li><li>执行unlock前必须先将共享变量副本同步到共享变量中</li></ul><h3 id="简述一下线程安全的三个特性" tabindex="-1"><a class="header-anchor" href="#简述一下线程安全的三个特性" aria-hidden="true">#</a> 简述一下线程安全的三个特性？</h3><p>  线程的三个特性指的是原子性、可见性和有序性。</p><p>  线程的<strong>原子性</strong>即以线程为单位，操作是原子的，是最小的执行单元。实现方式：</p><ul><li>加锁：可以通过synchorized和Lock锁(ReenTrantLock)实现，即通过加锁实现串行化达到同步的目的，以保证线程执行的原子性。</li><li>基本类型的读和赋值本身就具有原子性。</li><li>JUC提供的原子类通过CAS原理来保证原子性。</li></ul><p>  线程的<strong>可见性</strong>即某个线程修改了内存中共享变量的值时，共享变量的改变对所有的线程是可见的。实现方式：</p><ul><li>加锁：通过串行化的同步代码，保证同一时刻只有一个线程可以访问到共享资源，以此保证可见性。</li><li>volatile关键字：通过内存屏障实现保证共享变量修改的可见性。</li></ul><p>  线程的<strong>有序性</strong>即程序需要按照一定的顺序执行，期间会进行编译器的优化重排序、指令重排序、内存重排序等等，但是这些重排序的操作必须满足两个原则，以保证有序性：</p><ul><li>as-if-serial：不管编译器如何重排序，最后的执行结果不能改变。</li><li>happens-before原则： <ul><li>程序顺序原则：一个线程内必须保证语义的串行，代码必须按照顺序执行。</li><li>锁规则：解锁操作必须发生在下一个加锁操作之前。</li><li>volatile可见性：volatile修饰的关键字必须保证可见性，通过内存屏障，在共享变量每次被线程访问时，都会强迫从主内存中读取共享变量；当共享变量副本发生变化时，也都会强迫写回主内存。</li><li>线程启动规则：thread.start()方法先于它的每一个动作，比如线程A修改了B中共享变量的值，那么B启动时，那么A的修改应该是对B可见的。</li><li>传递性：A线程先于B线程、B线程先于C线程，那么A线程先于C线程。</li><li>线程终止规则：线程的所有操作应该是先于终止，比如jion()方法的作用就是等待线程的终止后执行主线程的某些操作。</li><li>线程中断原则：intercept()方法调用优先于被中断线程中检测到中断事件的发生(先中断才能检测到中断事件)。</li><li>对象的终结规则：构造方法的执行优先于finalize()方法。</li></ul></li></ul><h3 id="volatile关键字的作用是怎样的-如何实现的" tabindex="-1"><a class="header-anchor" href="#volatile关键字的作用是怎样的-如何实现的" aria-hidden="true">#</a> volatile关键字的作用是怎样的？如何实现的？</h3><p>  volatile的作用是保证共享变量的可见性，底层通过内存屏障实现，即在共享变量每次被线程访问时，都会强迫从主内存中读取共享变量；当共享变量副本发生变化时，也都会强迫写回主内存。</p><p>  打个比方讲就是，一个变量的地址，不仅你知道，别的线程也知道。当你的线程读写这个地址，别的线程也在做这种事，那么就需要告诉编译器，这个变量可能会同时被其他线程修改。这就是volatile关键字修饰变量的含义。</p><p>  同样的，如果是一个在你方法里的临时变量，通常情况下只有你这个现成使用它，编译器编译时就会认为，它生成汇编代码的时候就能重复使用已经加载到cpu寄存器里的值，编译器很清楚的知道这两者的等价性，也就是cpu寄存器里的值可以重复拿来用不用管其他的线程干了什么。</p><p>  如果说别的线程修改了这个值，其实就相当于之前读到cpu里的已经失效了。所以volatile就是告诉编译器，cpu寄存器里的值跟内存数据里的值并不能等价处理。</p><h3 id="简述一下final关键字和不变性原理" tabindex="-1"><a class="header-anchor" href="#简述一下final关键字和不变性原理" aria-hidden="true">#</a> 简述一下final关键字和不变性原理？</h3><p>  不变性指的是一个值一旦被初始化，那么就不能修改，引用、成员变量都不可变。final关键字就是保证不变性的，不可变的对象一定是线程安全的。</p><p>  final修饰范围：</p><ul><li>类：不可被继承</li><li>方法：不能被重写</li><li>变量：值不能被修改、引用不能被修改，但是被引用的对象可以修改。</li></ul><h3 id="synchronized关键字的作用是什么" tabindex="-1"><a class="header-anchor" href="#synchronized关键字的作用是什么" aria-hidden="true">#</a> synchronized关键字的作用是什么？</h3><p>  synchorized是一种对象锁，是可重入的，可以修饰代码块和方法。</p><p>  synchorized实现是通过对象的Monitor锁实现的，依赖于操作系统的互斥锁实现的。Monitor即对象头Markword中的一个字段，任何一个对象都有一个Monitor与之关联，当Monitor被一个线程持有后，Monitor就处于加锁状态。synchorized的加锁和解锁就是基于Monitor的进入和退出实现的。</p><p>  加锁和解锁的流程是这样的：</p><ol><li>当代码执行到synchorized修饰的代码部分，执行monitorenter指令，尝试获取Monitor的所有权。</li><li>monitor有一个计数器，如果计数器为0，说明没有线程持有Monitor，那么该线程进入Monitor，计数器+1。</li><li>如果该线程本身就持有该对象的Monitor，那么重入，即计数器再+1。</li><li>如果其他线程持有该对象的Monitor，即计数器不为0，那么会阻塞，直到计数器为0。</li><li>退出synchorized关键字修饰的代码时，前提条件肯定是该线程持有该对象的Monitor，然后计数器-1，重入的情况会嵌套-1，直到计数器为0表示该线程不持有锁。</li></ol><p>  synchorized对象锁在发生异常时会释放锁。</p><h3 id="synchorized锁膨胀升级过程是怎样的" tabindex="-1"><a class="header-anchor" href="#synchorized锁膨胀升级过程是怎样的" aria-hidden="true">#</a> synchorized锁膨胀升级过程是怎样的？</h3><p>  synchorized锁是为了解决线程安全的执行控制问题的一种机制，锁的膨胀升级是为了降低锁带来的性能消耗，因此并不会一开始就使用重量级锁。</p><p>  锁按照级别膨胀升级，过程是单向的：无锁状态--&gt;偏向锁--&gt;轻量级锁--&gt;重量级锁。</p><ul><li>无锁状态：任何线程都能访问资源。</li><li>偏向锁：资源被一个线程竞争，就会进入偏向锁状态。大多数情况下，锁不但不会竞争，还总是会被一个线程获得，这种情况为了避免同一个线程重复获得锁的资源消耗，引入偏向锁。进入偏向锁状态的Monitor会记录偏向线程ID，当线程再次请求时，可以迅速的获取锁。</li><li>轻量级锁：当不是同一个线程竞争资源时，偏向锁会升级为轻量级锁，当一个线程A获取到锁，另一个线程B会通过自旋(CAS)的方式不断尝试获取锁，线程不会阻塞，从而提高性能。</li><li>重量级锁：当竞争的线程自旋次数达到一定的阈值，或者一个线程获取到锁，有多个线程来竞争，就会升级为重量级锁。重量级锁的特点是未获取到锁的线程都会进入等待，重量级锁的切换需要从用户态切换内核态(等待的线程交给了系统内核挂起)，成本比较高。</li></ul><h3 id="synchorized为什么不再使用偏向锁" tabindex="-1"><a class="header-anchor" href="#synchorized为什么不再使用偏向锁" aria-hidden="true">#</a> synchorized为什么不再使用偏向锁？</h3><p>  java在版本15后废弃了偏向锁，其原因大概如下：</p><ul><li>首先通过CPU的CAS实现的轻量级锁，本身就不需要上下文的切换就能实现加锁和解锁，在竞争不是非常激烈的情况下，消耗本身也不大；当竞争激烈时，消耗与重量级锁也差不多，因此会选择升级。</li><li>偏向锁的本身目的也是为了解决重量级锁需要切换上下文的问题，而且只针对一个线程获取并不存在竞争的情况。但是实际上多线程条件下这种情况本身就很少见，而且偏向锁的实现依赖于对象头的偏向锁字段和threadId字段，官网中也说了偏向锁对JVM增加了巨大的复杂性，维护成本很高。</li></ul><p>  综上就取消了。</p><h3 id="synchorized和lock锁的区别是什么" tabindex="-1"><a class="header-anchor" href="#synchorized和lock锁的区别是什么" aria-hidden="true">#</a> synchorized和Lock锁的区别是什么？</h3><p>  JVM提供了几种锁的实现方式，归根到底分类两种：synchorized内置锁和Lock锁。Lock锁是JVM实现锁的一个顶层接口，Lock和synchorized在功能上有很大的区别，并不能互相代替。</p><p>  synchorized原理如上回答即可，synchorized出现异常不能释放，并且是个比较重的锁，加锁和释放锁的场景比较单一。Lock提供了几个API可以灵活的调用：</p><ul><li>lock：获取锁，如果被其他线程锁了，则本线程阻塞。</li><li>tryLock：尝试获取锁，不会阻塞立即返回布尔值。</li><li>tryLock(time)：在规定时间内获取锁，超过时间后不再阻塞。</li><li>unlock()：解锁。</li></ul><p>  Lock的典型实现是ReentrantLock，其实现原理是利用AQS机制，支持中断响应、超时和尝试获取，必须显式的释放锁，可以实现公平锁和非公平锁，并且可以关联多个条件队列，具有可重入的特性。</p><p>  在特性上的对比：</p><ul><li>实现原理：ReentrantLock使用AQS机制，synchorized使用Monitor锁和轻量级锁。</li><li>灵活性：ReentrantLock支持中断、响应、尝试获取等等，并且要显式解锁；synchorized自动释放。</li><li>锁的类型：ReentrantLock支持公平锁和非公平锁；synchorized是非公平锁。</li><li>条件队列：ReentrantLock支持多个条件队列；synchorized只有一个条件队列。</li><li>是否可重入：都可重入。</li></ul><h3 id="锁的分类" tabindex="-1"><a class="header-anchor" href="#锁的分类" aria-hidden="true">#</a> 锁的分类</h3><p>  锁根据一些分类维度可以分为：是否锁定共享资源--乐观锁和悲观锁、是否独占共享资源--共享锁和独占锁、线程是否排队等待--公平锁和非公平锁、同一个线程是否可以重入--重入锁和非重入锁、是否允许中断--中断锁和非中断锁、线程等待的状态--自旋锁和阻塞锁。</p><h3 id="什么是aqs" tabindex="-1"><a class="header-anchor" href="#什么是aqs" aria-hidden="true">#</a> 什么是AQS？</h3><p>  AQS通过实现一个先进先出的队列和一个资源状态来实现锁机制，核心思想是：</p><ul><li>如果被请求的共享资源是空闲的，则当前线程设置为工作线程，并且将共享资源的状态设定为锁定状态。</li><li>如果被请求的资源是占用的，那么会将线程放入队列中，并且有一套线程阻塞和唤醒时的锁分配机制来分配线程。这套机制可以实现共享/排他、公平/非公平、重入。</li></ul><h3 id="什么是cas原理" tabindex="-1"><a class="header-anchor" href="#什么是cas原理" aria-hidden="true">#</a> 什么是CAS原理？</h3><p>  CAS是指的Concurrent And Swap指令，是一个在并发情况下不能被打断的执行数据交换的CPU指令。其思想是假设被修改的对象当前值应该是A，如果确实是A则进行修改；如果不是A则说明该值被其他线程修改过，则不进行修改。</p><p>  CAS有着广泛的应用场景：</p><ul><li>乐观锁</li><li>并发容器ConcurrentHashMap使用CAS保证并发安全</li><li>原子类</li></ul><p>  CAS在Java中的核心实现是Unsafe类，通过native方法访问操作系统。其中原子类就是通过Unsafe类实现的。</p><p>  CAS有个ABA问题，即在操作过程中，假设被修改对象应该是A，就该过程中，其他线程将A修改为B又修改为A，这时其实已经发生了修改。解决方案是乐观锁，通过设定版本号来判断修改时间线。</p><h3 id="原子类如何实现的cas" tabindex="-1"><a class="header-anchor" href="#原子类如何实现的cas" aria-hidden="true">#</a> 原子类如何实现的CAS？</h3><ul><li>原子类利用Unsafe类执行CPU的CAS命令。</li><li>volatile关键字保证共享变量可见性。</li><li>使用do-while循环实现对CAS调用的自旋。</li></ul><h3 id="threadlocal的作用是什么-threadlocal是如何实现的" tabindex="-1"><a class="header-anchor" href="#threadlocal的作用是什么-threadlocal是如何实现的" aria-hidden="true">#</a> ThreadLocal的作用是什么？ThreadLocal是如何实现的？</h3><p>  ThreadLocal是存放线程独有的变量的一个对象。常用来实现Holder。其实现原理如下：</p><ul><li>每一个线程都有一个ThreadLocalMap，保存该线程的多个ThreadLocal。</li><li>ThreadLocalMap保存在Thread对象中。</li><li>提供了initialValue()方法用于初始化值，提供了set、get、remove方法对变量增删改。</li><li>需要特别注意使用拦截器清空对象，否则会OOM。</li></ul><h3 id="如何创建线程池-有哪些参数-都有什么作用-实现原理" tabindex="-1"><a class="header-anchor" href="#如何创建线程池-有哪些参数-都有什么作用-实现原理" aria-hidden="true">#</a> 如何创建线程池？有哪些参数，都有什么作用(实现原理)？</h3><p>  通过构造函数创建线程池，即new ThreadPoolExecutor。线程池的构造函数有6个核心参数：</p><ul><li>corePoolSize：核心线程数，核心线程数是线程池创建的会长期存活的线程数量。</li><li>maxPoolSize：最大线程数，是线程池为了应对流量不均衡的情况，所设置的允许创建的最大线程数量，超过核心线程数的线程在任务执行完成后会休眠。</li><li>keepAliveTime：线程存活时间，超过核心线程数的空闲线程在超过线程存活时间后会被回收。</li><li>workQueue：工作队列，用于存放用于执行的任务。 <ul><li>SynchronousQueue：直接交换队列，容量为1，仅仅作为任务中转。</li><li>LinkedBlockingQueue：无界队列，容量无限大，容易OOM。</li><li>ArrayBlockingQueue：有界队列，需要设置队列长度。</li></ul></li><li>threadFactory：线程工厂，用于指定创建线程的工厂，默认的线程工厂创建的线程都在同一个线程组，拥有一样的优先级并且不是守护线程。</li><li>handler：任务队列满员后的拒绝策略执行器。</li></ul><p>  除此之外，还可以直接声明5种线程池的实现类。</p><h3 id="如何设定线程数" tabindex="-1"><a class="header-anchor" href="#如何设定线程数" aria-hidden="true">#</a> 如何设定线程数？</h3><p>  线程池的线程数量的设定，我们一般情况下先会根据理论值估算：</p><ul><li>CPU密集型：主要是加解密、计算Hash、密集计算等业务，最大线程数一般设置为CPU核心数的1-2倍。</li><li>IO密集型：增删改查、通信调用，最大线程数一般设置为CPU的10-15倍也可以。</li><li>核心线程数 = CPU核心数 *(1+平均等待时间/平均工作时间)</li><li>估算设置后，一般需要在压力测试中实测压力曲线，然后再根据曲线做修改。</li></ul><h3 id="线程池都有哪些任务拒绝策略" tabindex="-1"><a class="header-anchor" href="#线程池都有哪些任务拒绝策略" aria-hidden="true">#</a> 线程池都有哪些任务拒绝策略？</h3><p>  线程池的一个参数是要求我们设置任务拒绝策略的执行器，一般任务拒绝策略会在Executor关闭时，或者Executor的线程数或者队列有边界时，达到最大边界时执行拒绝。</p><p>  常见的拒绝策略有：</p><ul><li>直接异常</li><li>埋没异常</li><li>埋没异常并且丢弃时间最久的任务</li><li>把任务发给提交线程的主线程处理，提供负反馈。</li></ul><h3 id="工作中都用到过哪些线程池" tabindex="-1"><a class="header-anchor" href="#工作中都用到过哪些线程池" aria-hidden="true">#</a> 工作中都用到过哪些线程池？</h3><p>  常见的线程池的实现有5种：</p><ul><li>FixedThreadPool：固定线程数量的线程池，特点是 <ul><li>核心线程数 = 最大线程数</li><li>keepAliveTime = 0</li><li>无界队列：LinkedBlockingQueue</li><li>有OOM风险</li></ul></li><li>SingleThreadExecutor：单线程线程池 <ul><li>核心线程数 = 最大线程数 = 1</li><li>keepAliveTime = 0</li><li>无界队列：LinkedBlockingQueue</li><li>有OOM风险</li></ul></li><li>CachedThreadPool：可缓存线程池 <ul><li>corePoolSize = 0</li><li>maxPoolSize = MAX</li><li>keepAliveTime = 60s</li><li>无队列：SynchronousQueue</li><li>有OOM风险(线程数量过多造成)</li></ul></li><li>ScheduledThreadPool：定时任务线程池 <ul><li>支持周期性定时任务</li><li>支持延迟执行</li><li>核心线程数自定义</li><li>最大线程数无上限</li><li>keepAliveTime = 0</li><li>延迟队列：DelayWorkQueue</li></ul></li><li>WorkingStealingPool：子任务线程池 <ul><li>需要产生子任务才能使用。</li><li>窃取能力：子任务有自己的队列，如果子任务完成，其他的子任务线程没有完成，那么会窃取其他线程的队列中的任务</li></ul></li></ul><p>  声明线程池除了以上两种方法，还需要特别说明的是定时任务线程池的构造参数：</p><ul><li>任务：现成具体需要执行的任务实现</li><li>首次执行的延迟时间</li><li>执行的间隔时间</li><li>时间单位</li></ul><h3 id="线程池的使用" tabindex="-1"><a class="header-anchor" href="#线程池的使用" aria-hidden="true">#</a> 线程池的使用</h3><p>  线程池的使用主要可以从几个方面说明：线程池的控制方法、线程池内部实现的主要属性的作用、线程池的监控方法和钩子方法四个部分。</p><p>  使用线程池一般使用其控制方法执行任务，这是线程池提供的API：</p><ul><li>execute(Runnable)：履行Runnabble任务</li><li>submit(Future)：提交Future任务</li><li>shutdown()：执行线程池关闭，并不是强制关闭，需要执行初始化关闭过程，会执行完成队列中已经存在的任务但是会拒绝新的任务</li><li>isShutdown()：判断是否进入停止状态。</li><li>isTerminated()：判断线程池是否真的关闭</li><li>awaitTermination()：检测在一定时间内线程是否停止，这是个阻塞方法，会返回线程池的三种状态 <ul><li>所有任务都关闭了</li><li>等待超时</li><li>等待过程被中断</li></ul></li><li>shutdownNow()：立即关闭线程池，并返回未执行任务的集合。</li></ul><p>  线程池内通过ctl属性的两个字段，存储线程的运行状态(runState)和线程池内的有效的线程数量(workerCount)。</p><p>  线程池提供了方法可以监控线程池的执行状况：</p><ul><li>getTaskCount()：获取已经执行和未执行的任务总数</li><li>getCompletedTaskCount()：获取已经完成的任务总数</li><li>getPoolSize()：获取当前线程数</li><li>getActiveCount：获取正在执行Task的线程数</li></ul><p>  线程池还提供了钩子方法，用于回调，在线程池的执行前后调用做前置和后置处理：</p><ul><li>实现钩子方法需要继承ThreadPoolExecutor，实现自己的线程池</li><li>重写beforeExecutor方法</li><li>重写afterExecutor方法</li></ul><h3 id="线程池的状态转换" tabindex="-1"><a class="header-anchor" href="#线程池的状态转换" aria-hidden="true">#</a> 线程池的状态转换</h3><h3 id="线程池是如何实现的" tabindex="-1"><a class="header-anchor" href="#线程池是如何实现的" aria-hidden="true">#</a> 线程池是如何实现的？</h3><h3 id="线程池如何做到核心线程复用" tabindex="-1"><a class="header-anchor" href="#线程池如何做到核心线程复用" aria-hidden="true">#</a> 线程池如何做到核心线程复用？</h3><h3 id="线程池如何做到核心线程不会被执行完毕" tabindex="-1"><a class="header-anchor" href="#线程池如何做到核心线程不会被执行完毕" aria-hidden="true">#</a> 线程池如何做到核心线程不会被执行完毕？</h3><h3 id="java线程池分配线程按照密集型分有那几类" tabindex="-1"><a class="header-anchor" href="#java线程池分配线程按照密集型分有那几类" aria-hidden="true">#</a> java线程池分配线程按照密集型分有那几类？</h3><p>io密集型和cpu密集型</p><h3 id="两种密集型如何分配线程数" tabindex="-1"><a class="header-anchor" href="#两种密集型如何分配线程数" aria-hidden="true">#</a> 两种密集型如何分配线程数？</h3><h3 id="为何这么分配线程数" tabindex="-1"><a class="header-anchor" href="#为何这么分配线程数" aria-hidden="true">#</a> 为何这么分配线程数？</h3><h3 id="用过哪些juc并发工具类-都是什么作用" tabindex="-1"><a class="header-anchor" href="#用过哪些juc并发工具类-都是什么作用" aria-hidden="true">#</a> 用过哪些JUC并发工具类，都是什么作用？</h3><ul><li>原子类</li><li>线程池</li><li>并发流程控制器</li><li>锁</li></ul><h3 id="是否了解future框架" tabindex="-1"><a class="header-anchor" href="#是否了解future框架" aria-hidden="true">#</a> 是否了解Future框架？</h3><h3 id="如何实现一个线程" tabindex="-1"><a class="header-anchor" href="#如何实现一个线程" aria-hidden="true">#</a> 如何实现一个线程？</h3><h3 id="todo-多线程基础" tabindex="-1"><a class="header-anchor" href="#todo-多线程基础" aria-hidden="true">#</a> todo 多线程基础</h3><h3 id="什么是线程安全" tabindex="-1"><a class="header-anchor" href="#什么是线程安全" aria-hidden="true">#</a> 什么是线程安全？</h3><h3 id="线程安全的数据结构" tabindex="-1"><a class="header-anchor" href="#线程安全的数据结构" aria-hidden="true">#</a> 线程安全的数据结构？</h3><h2 id="java高级特性" tabindex="-1"><a class="header-anchor" href="#java高级特性" aria-hidden="true">#</a> Java高级特性</h2><h3 id="什么是java的泛型机制" tabindex="-1"><a class="header-anchor" href="#什么是java的泛型机制" aria-hidden="true">#</a> 什么是Java的泛型机制？</h3><h3 id="什么是java的注解机制" tabindex="-1"><a class="header-anchor" href="#什么是java的注解机制" aria-hidden="true">#</a> 什么是Java的注解机制？</h3><h3 id="什么是java的反射机制" tabindex="-1"><a class="header-anchor" href="#什么是java的反射机制" aria-hidden="true">#</a> 什么是Java的反射机制？</h3><h3 id="什么是java的spi机制" tabindex="-1"><a class="header-anchor" href="#什么是java的spi机制" aria-hidden="true">#</a> 什么是Java的SPI机制？</h3><h2 id="java数据结构" tabindex="-1"><a class="header-anchor" href="#java数据结构" aria-hidden="true">#</a> Java数据结构</h2><h3 id="hashmap原理" tabindex="-1"><a class="header-anchor" href="#hashmap原理" aria-hidden="true">#</a> HashMap原理？</h3><h3 id="arraylist原理" tabindex="-1"><a class="header-anchor" href="#arraylist原理" aria-hidden="true">#</a> ArrayList原理？</h3><h3 id="linkedlist原理" tabindex="-1"><a class="header-anchor" href="#linkedlist原理" aria-hidden="true">#</a> LinkedList原理？</h3><h3 id="linkedhashmap原理" tabindex="-1"><a class="header-anchor" href="#linkedhashmap原理" aria-hidden="true">#</a> LinkedHashMap原理？</h3><h3 id="hashmap为什么不是线程安全的" tabindex="-1"><a class="header-anchor" href="#hashmap为什么不是线程安全的" aria-hidden="true">#</a> HashMap为什么不是线程安全的？</h3><h3 id="concurrenthashmap如何实现线程安全的" tabindex="-1"><a class="header-anchor" href="#concurrenthashmap如何实现线程安全的" aria-hidden="true">#</a> ConcurrentHashMap如何实现线程安全的？</h3><h2 id="java-io特性" tabindex="-1"><a class="header-anchor" href="#java-io特性" aria-hidden="true">#</a> Java IO特性</h2><h3 id="javaio是什么" tabindex="-1"><a class="header-anchor" href="#javaio是什么" aria-hidden="true">#</a> JavaIO是什么？</h3><p>  IO模型指的是用什么样的通道进行数据的发送和接收，Java支持三种网络IO模型：BIO、NIO和AIO。</p><h3 id="如何理解javaio的装饰者模式" tabindex="-1"><a class="header-anchor" href="#如何理解javaio的装饰者模式" aria-hidden="true">#</a> 如何理解JavaIO的装饰者模式？</h3><h3 id="什么是java的bio" tabindex="-1"><a class="header-anchor" href="#什么是java的bio" aria-hidden="true">#</a> 什么是Java的BIO</h3><p>  BIO全程Blocking IO，即同步阻塞IO模型，BIO的特点是一个客户端对应一个IO线程，IO代码里的read操作和accept是阻塞操作，如果连接不做数据读写会造成线程阻塞，并且如果请求压力大的话会造成server端线程数量过多。</p><h3 id="什么是java-nio-请说一下java-nio的多路复用原理" tabindex="-1"><a class="header-anchor" href="#什么是java-nio-请说一下java-nio的多路复用原理" aria-hidden="true">#</a> 什么是Java NIO？请说一下Java NIO的多路复用原理？</h3><p>  NIO指的是Non Blocking IO，即同步非阻塞模型，server端一个线程可以处理多个请求链接。NIO模型适合连接短但是多的场景，比如聊天、弹幕、服务器通讯。</p><p>  其原理是客户端发送的请求链接会注册到多路复用器selector上，多路复用器轮询请求链接，有IO请求的才会处理。</p><p>  NIO有三大核心组件：</p><ul><li>Buffer：缓冲区，每个channel都对应一个缓冲区，buffer和channel都可以读可以写。</li><li>Channel：每一个channel对应一个buffer缓冲区，buffer底层实现是一个数组。</li><li>Selector：多路复用器，channel会注册到selector上，由selector根据channel读写事件的发生将其交由某个空闲线程进行处理。</li></ul><p>  NIO的流程是这样的：</p><ol><li>Server端监听一个开放端口，client链接端口进行数据交互。</li><li>client会将链接放入buffer。</li><li>每个buffer对应一个channel，buffer会将读写事件放入channel。</li><li>channel会注册到多路复用器selector上。</li><li>selector底层使用Linux的epoll实现的，epoll会维护一个就绪事件列表rdlist。</li><li>channel有读写事件就会将链接放入就绪事件列表rdlist。</li><li>epoll会查询就绪事件列表，如果有就绪事件，交给Selecor。</li><li>selector交给空闲线程处理。</li></ol><h3 id="java-aio技术是什么" tabindex="-1"><a class="header-anchor" href="#java-aio技术是什么" aria-hidden="true">#</a> Java AIO技术是什么？</h3><p>  异步非阻塞IO，由操作系统完成后回调通知server端启动线程处理，一般适用于连接数多且链接时间长的服务。</p><h2 id="java新特性" tabindex="-1"><a class="header-anchor" href="#java新特性" aria-hidden="true">#</a> Java新特性</h2><h3 id="java-8-11的新特性" tabindex="-1"><a class="header-anchor" href="#java-8-11的新特性" aria-hidden="true">#</a> Java 8-11的新特性？</h3><h3 id="java-12-17的新特性" tabindex="-1"><a class="header-anchor" href="#java-12-17的新特性" aria-hidden="true">#</a> java 12-17的新特性？</h3><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/noErrorNoBug/docs/edit/master/docs/questions/Java面试题.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/9/10 01:12:29</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 749922109@qq.com">sunqiang</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/docs/questions/Java面试题.md" class="nav-link prev" arialabel="Java面试题"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->Java面试题</div></a><a href="/docs/questions/框架中间件面试题.md" class="nav-link next" arialabel="框架中间件面试题"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">框架中间件面试题<!----></div></a></nav><div class="giscus-wrapper" style="display:none;"><!----></div><!----></main><!--]--><footer class="footer-wrapper"><div class="footer">Apache License 2.0 | Copyright © 2018-present noErrorNoBug(sunqiang)</div><!----></footer></div><!--]--><!----><!--[--><!-- Root element of PhotoSwipe. Must have class pswp. --><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><!-- Background of PhotoSwipe. 
    It’s a separate element, as animating opacity is faster than rgba().--><div class="pswp__bg"></div><!-- Slides wrapper with overflow:hidden. --><div class="pswp__scroll-wrap"><!-- Container that holds slides. PhotoSwipe keeps only 3 slides in DOM to save memory. --><div class="pswp__container"><!-- don’t modify these 3 pswp__item elements, data is added later on --><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. --><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><!--  Controls are self-explanatory. Order can be changed. --><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="关闭"></button><button class="pswp__button pswp__button--share" title="分享"></button><button class="pswp__button pswp__button--fs" title="切换全屏"></button><button class="pswp__button pswp__button--zoom" title="缩放"></button><!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR --><!-- element will get class pswp__preloader--active when preloader is running --><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="上一个 (左箭头)"></button><button class="pswp__button pswp__button--arrow--right" title="下一个 (右箭头)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div><!--]--><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewbox="0 0 1024 1024" arialabelledby="close"><title id="close" lang="en">close icon</title><g fill="currentColor"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></g></svg></button><div class="logo"><!--v-if--><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!--v-if--><!--v-if--></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button class="install-button">安装 <span></span></button><button class="cancel-button">取消</button></div></div></div></div><!--]--></div>
    <script type="module" src="/docs/assets/app.7eb989d9.js" defer></script>
  </body>
</html>
