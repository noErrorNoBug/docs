<!DOCTYPE html>
<html lang="zh-CN" data-theme="light">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-beta.36" />
    <meta name="theme" content="VuePress Theme Hope" />
    <meta property="og:url" content="https://github.com/noErrorNoBug/docs/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html"><meta property="og:site_name" content="后端技术笔记"><meta property="og:title" content="框架中间件面试题"><meta property="og:type" content="article"><meta property="og:locale" content="zh-CN"><link rel="icon" href="./favicon.ico"><meta name="author" content="noErrorNoBug"><meta name="keywords" content="java,JVM,并发,算法,mysql,redis,mongodb,elasticsearch,spring,springboot,netty,mq,kafka,分布式,微服务,商城,秒杀,数据仓储,网络协议,Docker,Linux"><link rel="manifest" href="/docs/manifest.webmanifest" crossorigin="use-credentials"><meta name="theme-color" content="#F0FFF0"><link rel="apple-touch-icon" href="/icons/icon-192x192.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="white"><link rel="mask-icon" href="/icons/icon-256x256.png" color="#F0FFF0"><meta name="msapplication-TileImage" content="/icons/icon-384x384.png"><meta name="msapplication-TileColor" content="#46bd87"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover"><title>框架中间件面试题 | 后端技术笔记</title><meta name="description" content="noErrorNoBug(sunqiang)的后端技术笔记">
    <style>
      :root {
        --bg-color: #fff;
      }

      html[data-theme="dark"] {
        --bg-color: #1d2025;
      }

      html,
      body {
        background-color: var(--bg-color);
      }
    </style>
    <script>
      const userMode = localStorage.getItem("vuepress-theme-hope-scheme");
      const systemDarkMode =
        window.matchMedia &&
        window.matchMedia("(prefers-color-scheme: dark)").matches;

      if (userMode === "dark" || (userMode !== "light" && systemDarkMode)) {
        document.querySelector("html").setAttribute("data-theme", "dark");
      }
    </script>
    <link rel="stylesheet" href="/docs/assets/style.004f05f4.css">
    <link rel="modulepreload" href="/docs/assets/app.7eb989d9.js"><link rel="modulepreload" href="/docs/assets/框架中间件面试题.html.da5ed092.js"><link rel="modulepreload" href="/docs/assets/框架中间件面试题.html.74ca3c48.js">
  </head>
  <body>
    <div id="app"><!--[--><!--[--><!--[--><span tabindex="-1"></span><a href="#main-content" class="skip-link sr-only">Skip to content</a><!--]--><div class="theme-container no-sidebar has-toc sidebar-open"><!--[--><header class="navbar"><button class="toggle-sidebar-button" title="Toggle Sidebar"><span class="icon"></span></button><a href="/docs/" class="home-link"><img class="logo light" src="/docs/logo.svg" alt="后端技术笔记"><img class="logo dark light" src="/docs/logo.svg" alt="后端技术笔记"><span class="site-name hide-in-pad">后端技术笔记</span><!--[--><!----><!--]--></a><nav class="nav-links" style=""><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="面试题"><span class="title"><!---->面试题</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><a href="/docs/questions/Java%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="nav-link" arialabel="Java面试题"><!---->Java面试题<!----></a></li><li class="dropdown-item"><a href="/docs/questions/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="nav-link" arialabel="数据存储中间件面试题"><!---->数据存储中间件面试题<!----></a></li><li class="dropdown-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="router-link-active router-link-exact-active nav-link active" arialabel="框架中间件面试题"><!---->框架中间件面试题<!----></a></li><li class="dropdown-item"><a href="/docs/questions/%E5%88%86%E5%B8%83%E5%BC%8F%E5%92%8C%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%9D%A2%E8%AF%95%E9%A2%98.html" class="nav-link" arialabel="分布式和微服务面试题"><!---->分布式和微服务面试题<!----></a></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="Java"><span class="title"><!---->Java</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>面向对象|基础</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/java/basic/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B.html" class="nav-link" arialabel="面向对象特性"><!---->面向对象特性<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/basic/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.html" class="nav-link" arialabel="Java基础知识"><!---->Java基础知识<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/basic/Java%E6%B3%9B%E5%9E%8B%E6%9C%BA%E5%88%B6.html" class="nav-link" arialabel="Java高级特性"><!---->Java高级特性<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JAVA 集合框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Collection 集合"><!---->Collection 集合<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Map 集合"><!---->Map 集合<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="并发集合框架"><!---->并发集合框架<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JAVA 并发框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="并发理论基础"><!---->并发理论基础<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="多线程基础"><!---->多线程基础<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="关键字详解"><!---->关键字详解<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="集合与并发集合"><!---->集合与并发集合<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="线程池"><!---->线程池<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="CAS原理和原子类"><!---->CAS原理和原子类<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="AQS原理和锁机制"><!---->AQS原理和锁机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="并发流程控制"><!---->并发流程控制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Disruptor框架"><!---->Disruptor框架<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="ThreadLocal"><!---->ThreadLocal<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="并发设计模式"><!---->并发设计模式<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JAVA IO框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="JAVA IO"><!---->JAVA IO<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="JAVA NIO"><!---->JAVA NIO<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JVM原理</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link" arialabel="JVM类加载机制"><!---->JVM类加载机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html" class="nav-link" arialabel="JVM内存知识"><!---->JVM内存知识<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/jvm/%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html" class="nav-link" arialabel="JVM垃圾回收原理"><!---->JVM垃圾回收原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/jvm/%E5%AF%B9%E8%B1%A1%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.html" class="nav-link" arialabel="JVM调优思路"><!---->JVM调优思路<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html" class="nav-link" arialabel="JVM线上调试排查"><!---->JVM线上调试排查<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>JAVA 版本特性</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/java/version/java8/java8%E7%89%B9%E6%80%A7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html" class="nav-link" arialabel="Java8特性"><!---->Java8特性<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/version/java11/java9%E5%88%B0java11%E7%89%B9%E6%80%A7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html" class="nav-link" arialabel="java8升java11特性"><!---->java8升java11特性<!----></a></li><li class="dropdown-subitem"><a href="/docs/java/version/java17/java12%E5%88%B0java17%E7%89%B9%E6%80%A7%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.html" class="nav-link" arialabel="java11升java17特性"><!---->java11升java17特性<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="算法"><span class="title"><!---->算法</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据结构</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="复杂度析分析"><!---->复杂度析分析<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="线性表相关数据结构"><!---->线性表相关数据结构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="树相关数据结构"><!---->树相关数据结构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="堆相关数据结构"><!---->堆相关数据结构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="图相关数据结构"><!---->图相关数据结构<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>常用算法</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="排序算法"><!---->排序算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="查找算法"><!---->查找算法<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>算法思想</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="动态规划"><!---->动态规划<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分治算法"><!---->分治算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="二分法"><!---->二分法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="搜索算法"><!---->搜索算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="回溯算法"><!---->回溯算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="贪心算法"><!---->贪心算法<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>领域算法实践</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="加密算法"><!---->加密算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="字符串匹配算法"><!---->字符串匹配算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据一致性算法"><!---->数据一致性算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="负载均衡算法"><!---->负载均衡算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/algorithm/domain/%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95.html" class="nav-link" arialabel="限流算法"><!---->限流算法<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据处理算法"><!---->数据处理算法<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="数据库"><span class="title"><!---->数据库</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据库基础</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据库理论"><!---->数据库理论<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="SQL语言"><!---->SQL语言<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>SQL数据库 Mysql</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="索引原理"><!---->索引原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="存储引擎"><!---->存储引擎<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构原理"><!---->架构原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="事务机制"><!---->事务机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="性能优化"><!---->性能优化<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分库分表和读写分离"><!---->分库分表和读写分离<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Nosql数据库 Redis</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据类型和数据结构"><!---->数据类型和数据结构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高可用集群原理"><!---->高可用集群原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据持久化原理"><!---->数据持久化原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高性能原理"><!---->高性能原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="性能优化要点"><!---->性能优化要点<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="典型应用实现"><!---->典型应用实现<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Nosql数据库 ElasticSearch</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Elastic Stack生态"><!---->Elastic Stack生态<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="查询和聚合"><!---->查询和聚合<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="复杂搜索策略"><!---->复杂搜索策略<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="聚合匹配"><!---->聚合匹配<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据建模"><!---->数据建模<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="核心原理"><!---->核心原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="优化思路"><!---->优化思路<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="框架|中间件"><span class="title"><!---->框架|中间件</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring Framework</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="控制反转(IOC)"><!---->控制反转(IOC)<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="面向切面编程(AOP)"><!---->面向切面编程(AOP)<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="事务机制"><!---->事务机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="MVC机制"><!---->MVC机制<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="基于注解配置"><!---->基于注解配置<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="WebFlux"><!---->WebFlux<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring Boot</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="约定大于配置"><!---->约定大于配置<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="自动装配原理"><!---->自动装配原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="组件集成"><!---->组件集成<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>ORM框架</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Mybatis核心原理"><!---->Mybatis核心原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Mybatis-Plus简化开发"><!---->Mybatis-Plus简化开发<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="WEB容器"><span class="title"><!---->WEB容器</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Nginx容器</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构及配置"><!---->架构及配置<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="性能调优"><!---->性能调优<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Tomcat容器</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Web请求过程"><!---->Web请求过程<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="启停原理"><!---->启停原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="网络原理"><!---->网络原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="热加载和热部署"><!---->热加载和热部署<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Netty容器</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Netty核心架构"><!---->Netty核心架构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Netty线程模型实现原理"><!---->Netty线程模型实现原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Netty数据交换实现原理"><!---->Netty数据交换实现原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Netty优化"><!---->Netty优化<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="消息队列"><span class="title"><!---->消息队列</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>RocketMQ</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="TODO"><!---->TODO<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Kafka</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Kafka核心原理"><!---->Kafka核心原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="典型应用方案"><!---->典型应用方案<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="调优思路分析"><!---->调优思路分析<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>RabbitMQ</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构原理"><!---->架构原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="集群原理"><!---->集群原理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="典型应用方案"><!---->典型应用方案<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="微服务"><span class="title"><!---->微服务</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring Cloud 生态</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/microservice/loadbalance/LoadBalancer%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="LoadBalancer:负载均衡器"><!---->LoadBalancer:负载均衡器<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/feign/OpenFeign%E6%9E%B6%E6%9E%84%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="OpenFeign:函数式调用"><!---->OpenFeign:函数式调用<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/gateway/Gateway%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="Gateway:高可用网关API"><!---->Gateway:高可用网关API<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/auth/SpringSecurity%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="Security:认证和授权"><!---->Security:认证和授权<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="SkyWalking:链路追踪"><!---->SkyWalking:链路追踪<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="SpringCloud扩展点"><!---->SpringCloud扩展点<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Spring Cloud Alibaba 生态</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/microservice/register/%E5%9F%BA%E4%BA%8EAP%E6%9E%B6%E6%9E%84%E4%B8%8B%E7%9A%84Nacos%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8E%9F%E7%90%86.html" class="nav-link" arialabel="Nacos:服务注册与发现"><!---->Nacos:服务注册与发现<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/config/%E5%9F%BA%E4%BA%8ENacos%E7%9A%84%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0.html" class="nav-link" arialabel="Nacos:配置中心"><!---->Nacos:配置中心<!----></a></li><li class="dropdown-subitem"><a href="/docs/microservice/sentinel/%E5%9F%BA%E4%BA%8ESentinel%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81.html" class="nav-link" arialabel="Sentinel:限流和降级"><!---->Sentinel:限流和降级<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Seata:分布式事务"><!---->Seata:分布式事务<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="方法论|系统设计"><span class="title"><!---->方法论|系统设计</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>开发原则</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="代码设计原则"><!---->代码设计原则<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="代码规范和重构"><!---->代码规范和重构<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="开源协议和系统认证"><!---->开源协议和系统认证<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>设计模式范式</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/patterns/build/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html" class="nav-link" arialabel="创建型范式"><!---->创建型范式<!----></a></li><li class="dropdown-subitem"><a href="/docs/patterns/construct/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html" class="nav-link" arialabel="结构型范式"><!---->结构型范式<!----></a></li><li class="dropdown-subitem"><a href="/docs/patterns/action/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.html" class="nav-link" arialabel="行为型范式"><!---->行为型范式<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>分布式理论</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/methodology/distribution/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9.html" class="nav-link" arialabel="分布式理论和模型"><!---->分布式理论和模型<!----></a></li><li class="dropdown-subitem"><a href="/docs/methodology/transaction/X_OPEN%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.html" class="nav-link" arialabel="分布式事务理论"><!---->分布式事务理论<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="微服务理论"><!---->微服务理论<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="架构|分布式"><span class="title"><!---->架构|分布式</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>系统架构</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构视角及演进"><!---->架构视角及演进<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="架构的模式与核心要素"><!---->架构的模式与核心要素<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高并发架构要素"><!---->高并发架构要素<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高可用架构要素"><!---->高可用架构要素<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高性能架构要素"><!---->高性能架构要素<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>分布式系统设计</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="全局唯一ID"><!---->全局唯一ID<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式锁"><!---->分布式锁<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式事务"><!---->分布式事务<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式缓存"><!---->分布式缓存<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式任务"><!---->分布式任务<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式会话"><!---->分布式会话<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式链路追踪"><!---->分布式链路追踪<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式文件"><!---->分布式文件<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式存储"><!---->分布式存储<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式计算"><!---->分布式计算<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>系统设计案例</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="秒杀系统案例"><!---->秒杀系统案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="后台管理系统案例"><!---->后台管理系统案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据同步案例"><!---->数据同步案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="商城架构案例"><!---->商城架构案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="轻量单体限流框架案例"><!---->轻量单体限流框架案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="轻量消息系统案例"><!---->轻量消息系统案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="OSS单点登录案例"><!---->OSS单点登录案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高可用网关案例"><!---->高可用网关案例<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="认证授权服务案例"><!---->认证授权服务案例<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="大数据"><span class="title"><!---->大数据</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>数据同步</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="canal:数据库准实时同步"><!---->canal:数据库准实时同步<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>日志收集</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="ELK日志数据收集"><!---->ELK日志数据收集<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="项目|优化"><span class="title"><!---->项目|优化</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>系统性能优化</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Java编程性能调优"><!---->Java编程性能调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="多线程调优"><!---->多线程调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="JVM性能检测及调优"><!---->JVM性能检测及调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="设计模式调优"><!---->设计模式调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="数据库调优"><!---->数据库调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="基础设施优化"><!---->基础设施优化<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="系统网络调优"><!---->系统网络调优<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分布式系统优化"><!---->分布式系统优化<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="业务开发优化"><!---->业务开发优化<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>项目重构|项目设计</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="一套分布式高可用架构选型"><!---->一套分布式高可用架构选型<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="商城系统"><!---->商城系统<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="秒杀系统"><!---->秒杀系统<!----></a></li><li class="dropdown-subitem"><a href="/docs/projects/uua/UUA%E8%AE%A4%E8%AF%81%E4%B8%AD%E5%BF%83%E5%AE%9E%E7%8E%B0%E6%A1%88%E4%BE%8B.html" class="nav-link" arialabel="认证授权系统"><!---->认证授权系统<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="日志中心系统"><!---->日志中心系统<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="基于数据库的订阅中心"><!---->基于数据库的订阅中心<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="高可用网关方案"><!---->高可用网关方案<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="单机可插拔限流框架"><!---->单机可插拔限流框架<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="幂等性框架"><!---->幂等性框架<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="基于Flink的实时推荐系统"><!---->基于Flink的实时推荐系统<!----></a></li></ul></li></ul></button></div></div><div class="nav-item hide-in-mobile"><div class="dropdown-wrapper"><button class="dropdown-title" type="button" arialabel="工具|部署"><span class="title"><!---->工具|部署</span><span class="arrow"></span><ul class="nav-dropdown"><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>开发工具</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="常用类库"><!---->常用类库<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="代码质量保障"><!---->代码质量保障<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="常用表达式"><!---->常用表达式<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="代码安全"><!---->代码安全<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Linux|Shell脚本</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Shell脚本"><!---->Shell脚本<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="文本操作命令"><!---->文本操作命令<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="系统操作命令"><!---->系统操作命令<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="系统管理命令"><!---->系统管理命令<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>网络协议|抓包工具</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Http1.1协议"><!---->Http1.1协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="WebSocket协议"><!---->WebSocket协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Http2协议"><!---->Http2协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="TLS/SSL协议"><!---->TLS/SSL协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="TCP协议"><!---->TCP协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="UDP协议"><!---->UDP协议<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="IP协议"><!---->IP协议<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>Docker容器化</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="容器进程管理"><!---->容器进程管理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="容器内存管理"><!---->容器内存管理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="容器存储管理"><!---->容器存储管理<!----></a></li></ul></li><li class="dropdown-item"><h4 class="dropdown-subtitle"><span>代码管理|依赖管理</span></h4><ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Git常用功能"><!---->Git常用功能<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="分支管理模式"><!---->分支管理模式<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="Maven依赖管理"><!---->Maven依赖管理<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="GitHub常用功能"><!---->GitHub常用功能<!----></a></li><li class="dropdown-subitem"><a href="/docs/guide.html" class="nav-link" arialabel="常用开源工具"><!---->常用开源工具<!----></a></li></ul></li></ul></button></div></div></nav><div class="nav-actions-wrapper"><!--[--><!----><!--]--><div class="nav-item"><!----></div><div class="nav-item"><a class="repo-link" href="https://github.com/noErrorNoBug" target="_blank" rel="noopener noreferrer"><svg xmlns="http://www.w3.org/2000/svg" class="icon github-icon" viewbox="0 0 1024 1024" arialabelledby="github" style="width:1.25rem;height:1.25rem;vertical-align:middle;"><title id="github" lang="en">github icon</title><g fill="currentColor"><path d="M511.957 21.333C241.024 21.333 21.333 240.981 21.333 512c0 216.832 140.544 400.725 335.574 465.664 24.49 4.395 32.256-10.07 32.256-23.083 0-11.69.256-44.245 0-85.205-136.448 29.61-164.736-64.64-164.736-64.64-22.315-56.704-54.4-71.765-54.4-71.765-44.587-30.464 3.285-29.824 3.285-29.824 49.195 3.413 75.179 50.517 75.179 50.517 43.776 75.008 114.816 53.333 142.762 40.79 4.523-31.66 17.152-53.377 31.19-65.537-108.971-12.458-223.488-54.485-223.488-242.602 0-53.547 19.114-97.323 50.517-131.67-5.035-12.33-21.93-62.293 4.779-129.834 0 0 41.258-13.184 134.912 50.346a469.803 469.803 0 0 1 122.88-16.554c41.642.213 83.626 5.632 122.88 16.554 93.653-63.488 134.784-50.346 134.784-50.346 26.752 67.541 9.898 117.504 4.864 129.834 31.402 34.347 50.474 78.123 50.474 131.67 0 188.586-114.73 230.016-224.042 242.09 17.578 15.232 33.578 44.672 33.578 90.454v135.85c0 13.142 7.936 27.606 32.854 22.87C862.25 912.597 1002.667 728.747 1002.667 512c0-271.019-219.648-490.667-490.71-490.667z"></path></g></svg></a></div><div class="nav-item hide-in-mobile"><button id="appearance-switch"><svg xmlns="http://www.w3.org/2000/svg" class="icon auto-icon" viewbox="0 0 1024 1024" arialabelledby="auto" style="display:block;"><title id="auto" lang="en">auto icon</title><g fill="currentColor"><path d="M512 992C246.92 992 32 777.08 32 512S246.92 32 512 32s480 214.92 480 480-214.92 480-480 480zm0-840c-198.78 0-360 161.22-360 360 0 198.84 161.22 360 360 360s360-161.16 360-360c0-198.78-161.22-360-360-360zm0 660V212c165.72 0 300 134.34 300 300 0 165.72-134.28 300-300 300z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon dark-icon" viewbox="0 0 1024 1024" arialabelledby="dark" style="display:none;"><title id="dark" lang="en">dark icon</title><g fill="currentColor"><path d="M524.8 938.667h-4.267a439.893 439.893 0 0 1-313.173-134.4 446.293 446.293 0 0 1-11.093-597.334A432.213 432.213 0 0 1 366.933 90.027a42.667 42.667 0 0 1 45.227 9.386 42.667 42.667 0 0 1 10.24 42.667 358.4 358.4 0 0 0 82.773 375.893 361.387 361.387 0 0 0 376.747 82.774 42.667 42.667 0 0 1 54.187 55.04 433.493 433.493 0 0 1-99.84 154.88 438.613 438.613 0 0 1-311.467 128z"></path></g></svg><svg xmlns="http://www.w3.org/2000/svg" class="icon light-icon" viewbox="0 0 1024 1024" arialabelledby="light" style="display:none;"><title id="light" lang="en">light icon</title><g fill="currentColor"><path d="M952 552h-80a40 40 0 0 1 0-80h80a40 40 0 0 1 0 80zM801.88 280.08a41 41 0 0 1-57.96-57.96l57.96-58a41.04 41.04 0 0 1 58 58l-58 57.96zM512 752a240 240 0 1 1 0-480 240 240 0 0 1 0 480zm0-560a40 40 0 0 1-40-40V72a40 40 0 0 1 80 0v80a40 40 0 0 1-40 40zm-289.88 88.08-58-57.96a41.04 41.04 0 0 1 58-58l57.96 58a41 41 0 0 1-57.96 57.96zM192 512a40 40 0 0 1-40 40H72a40 40 0 0 1 0-80h80a40 40 0 0 1 40 40zm30.12 231.92a41 41 0 0 1 57.96 57.96l-57.96 58a41.04 41.04 0 0 1-58-58l58-57.96zM512 832a40 40 0 0 1 40 40v80a40 40 0 0 1-80 0v-80a40 40 0 0 1 40-40zm289.88-88.08 58 57.96a41.04 41.04 0 0 1-58 58l-57.96-58a41 41 0 0 1 57.96-57.96z"></path></g></svg></button></div><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form><button class="toggle-navbar-button" aria-label="Toggle Navbar" aria-expanded="false" aria-controls="nav-screen"><span class="button-container"><span class="button-top"></span><span class="button-middle"></span><span class="button-bottom"></span></span></button><!--[--><!----><!--]--></div></header><!----><!--]--><!----><div class="toggle-sidebar-wrapper"><span class="arrow left"></span></div><aside class="sidebar hide-icon"><!--[--><!----><!--]--><ul class="sidebar-links"></ul><!--[--><!----><!--]--></aside><!--[--><main class="page" id="main-content"><!----><nav class="breadcrumb disable"></nav><div class="page-title"><h1><!---->框架中间件面试题</h1><div class="article-info"><span class="author-info" arialabel="作者🖊" data-balloon-pos="down" isoriginal="false" pageview="false" color="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon author-icon" viewbox="0 0 1024 1024" arialabelledby="author"><title id="author" lang="en">author icon</title><g fill="currentColor"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z"></path></g></svg><span><a class="author-item" href="https://noerrornobug.github.io/docs/" target="_blank" rel="noopener noreferrer">noErrorNoBug(sunqiang)</a></span><span property="author" content="noErrorNoBug(sunqiang)"></span></span><span class="date-info" arialabel="写作日期📅" data-balloon-pos="down" isoriginal="false" pageview="false" color="true"><svg xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon" viewbox="0 0 1024 1024" arialabelledby="calendar"><title id="calendar" lang="en">calendar icon</title><g fill="currentColor"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 01-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 01-33.473-33.473V143.657H180.6A134.314 134.314 0 0046.66 277.595v535.756A134.314 134.314 0 00180.6 947.289h669.74a134.36 134.36 0 00133.94-133.938V277.595a134.314 134.314 0 00-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 01-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 01-33.472 33.473z"></path></g></svg><span>2022年9月4日</span><meta property="datePublished" content="2022-09-04T08:16:00.000Z"></span></div><hr></div><div class="toc-place-holder"><aside id="toc-list"><div class="toc-header">此页内容</div><div class="toc-wrapper"><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-ioc-容器" class="router-link-active router-link-exact-active toc-link level2">Spring IOC 容器</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是ioc-什么是di" class="router-link-active router-link-exact-active toc-link level3">什么是IOC？什么是DI？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何将一个类交给spring管理" class="router-link-active router-link-exact-active toc-link level3">如何将一个类交给Spring管理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beandefinition是什么" class="router-link-active router-link-exact-active toc-link level3">BeanDefinition是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beandefinitionreader是什么" class="router-link-active router-link-exact-active toc-link level3">BeanDefinitionReader是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beandefinitionscanner是什么" class="router-link-active router-link-exact-active toc-link level3">BeanDefinitionScanner是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beandefinitionregistry是什么" class="router-link-active router-link-exact-active toc-link level3">BeanDefinitionRegistry是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beanfactory是什么" class="router-link-active router-link-exact-active toc-link level3">BeanFactory是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring上下文和beanfactory有什么区别" class="router-link-active router-link-exact-active toc-link level3">Spring上下文和BeanFactory有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是factorybean" class="router-link-active router-link-exact-active toc-link level3">什么是FactoryBean？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-ioc容器的加载过程是怎样的" class="router-link-active router-link-exact-active toc-link level3">Spring IOC容器的加载过程是怎样的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#bean的加载过程-生命周期-是怎样的" class="router-link-active router-link-exact-active toc-link level3">Bean的加载过程(生命周期)是怎样的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-ioc都有哪些扩展点" class="router-link-active router-link-exact-active toc-link level3">Spring IOC都有哪些扩展点？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么某些情况下-value注入不了" class="router-link-active router-link-exact-active toc-link level3">为什么某些情况下@Value注入不了？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#" class="router-link-active router-link-exact-active toc-link level3"></a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#有哪些方式可以将bean对象给到spring容器中" class="router-link-active router-link-exact-active toc-link level3">有哪些方式可以将Bean对象给到Spring容器中？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring的单例bean线程是安全的吗-todo" class="router-link-active router-link-exact-active toc-link level3">Spring的单例Bean线程是安全的吗？todo</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-ioc容器如何解析配置类" class="router-link-active router-link-exact-active toc-link level3">Spring IOC容器如何解析配置类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#带有-configuration和不带-configuration有什么区别" class="router-link-active router-link-exact-active toc-link level3">带有@Configuration和不带@Configuration有什么区别？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#componentscan如何被解析的" class="router-link-active router-link-exact-active toc-link level3">@ComponentScan如何被解析的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是循环依赖" class="router-link-active router-link-exact-active toc-link level3">什么是循环依赖？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#循环依赖解决的大致思路" class="router-link-active router-link-exact-active toc-link level3">循环依赖解决的大致思路？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么需要二级缓存和三级缓存-分别是做什么的" class="router-link-active router-link-exact-active toc-link level3">为什么需要二级缓存和三级缓存？分别是做什么的？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-如何解决的循环依赖问题" class="router-link-active router-link-exact-active toc-link level3">Spring 如何解决的循环依赖问题？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring有没有解决构造函数的循环依赖" class="router-link-active router-link-exact-active toc-link level3">Spring有没有解决构造函数的循环依赖？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring有没有解决多例模式下的循环依赖" class="router-link-active router-link-exact-active toc-link level3">Spring有没有解决多例模式下的循环依赖？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何创建一个spring监听器" class="router-link-active router-link-exact-active toc-link level3">如何创建一个Spring监听器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring事件监听机制是什么" class="router-link-active router-link-exact-active toc-link level3">Spring事件监听机制是什么？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-aop" class="router-link-active router-link-exact-active toc-link level2">Spring AOP</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-aop的实现原理" class="router-link-active router-link-exact-active toc-link level3">Spring AOP的实现原理？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-事务机制" class="router-link-active router-link-exact-active toc-link level2">Spring 事务机制</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring事务的传播行为" class="router-link-active router-link-exact-active toc-link level3">Spring事务的传播行为</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-事务的实现原理" class="router-link-active router-link-exact-active toc-link level3">Spring 事务的实现原理</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么内部方法调用事务会失效" class="router-link-active router-link-exact-active toc-link level3">为什么内部方法调用事务会失效？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-mvc" class="router-link-active router-link-exact-active toc-link level2">Spring MVC</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-mvc的执行流程以及核心组件" class="router-link-active router-link-exact-active toc-link level3">Spring MVC的执行流程以及核心组件？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-容器和spring-mvc容器是什么关系" class="router-link-active router-link-exact-active toc-link level3">Spring 容器和Spring MVC容器是什么关系？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis" class="router-link-active router-link-exact-active toc-link level2">Mybatis</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis的整体架构" class="router-link-active router-link-exact-active toc-link level3">Mybatis的整体架构</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是mybaits的一级缓存和二级缓存" class="router-link-active router-link-exact-active toc-link level3">什么是Mybaits的一级缓存和二级缓存？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何解析配置文件" class="router-link-active router-link-exact-active toc-link level3">Mybatis如何解析配置文件？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何解析sql" class="router-link-active router-link-exact-active toc-link level3">Mybatis如何解析Sql？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何实现参数映射" class="router-link-active router-link-exact-active toc-link level3">Mybatis如何实现参数映射？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何解析查询结果" class="router-link-active router-link-exact-active toc-link level3">Mybatis如何解析查询结果？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何执行数据查询" class="router-link-active router-link-exact-active toc-link level3">Mybatis如何执行数据查询？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis的插件-plugin-执行原理是什么" class="router-link-active router-link-exact-active toc-link level3">Mybatis的插件(Plugin)执行原理是什么？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何利用spring扩展点进行整合" class="router-link-active router-link-exact-active toc-link level3">Mybatis如何利用Spring扩展点进行整合？</a></li><!----><!--]--></ul><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot" class="router-link-active router-link-exact-active toc-link level2">SpringBoot</a></li><ul class="toc-list"><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#import的用法" class="router-link-active router-link-exact-active toc-link level3">@Import的用法？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么springboot不使用importselector的方式注入配置类" class="router-link-active router-link-exact-active toc-link level3">为什么SpringBoot不使用ImportSelector的方式注入配置类？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#deferredimportselector对bean的加载顺序的影响" class="router-link-active router-link-exact-active toc-link level3">DeferredImportSelector对Bean的加载顺序的影响？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot自动装配原理" class="router-link-active router-link-exact-active toc-link level3">SpringBoot自动装配原理？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何实现一个自定义的starter完成自动装配" class="router-link-active router-link-exact-active toc-link level3">如何实现一个自定义的Starter完成自动装配？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot为什么jar包可以直接运行" class="router-link-active router-link-exact-active toc-link level3">SpringBoot为什么Jar包可以直接运行？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot如何启动spring容器" class="router-link-active router-link-exact-active toc-link level3">SpringBoot如何启动Spring容器？</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot的spi机制和java的spi机制有什么区别-todo-springboot的题需要从网上找一下答案。" class="router-link-active router-link-exact-active toc-link level3">SpringBoot的SPI机制和Java的SPI机制有什么区别？ todo springboot的题需要从网上找一下答案。</a></li><!----><!--]--><!--[--><li class="toc-item"><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#如果是自身维护starter组件-是不需要维护spring-factories文件的-这个文件统一配置在spring-boot-configuration包里-如果需要加载的一些组件用不到-需不需要把这里面的组件全部加载-todo" class="router-link-active router-link-exact-active toc-link level3">如果是自身维护Starter组件，是不需要维护spring.factories文件的，这个文件统一配置在spring-boot-configuration包里，如果需要加载的一些组件用不到，需不需要把这里面的组件全部加载？todo</a></li><!----><!--]--></ul><!--]--></ul></div></aside></div><!----><div class="theme-hope-content"><!--[--><div class="custom-container info"><p class="custom-container-title">相关信息</p><p>  面试题话术汇总，方便面试复习</p></div><nav class="table-of-contents"><ul><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-ioc-容器" class="router-link-active router-link-exact-active">Spring IOC 容器</a><ul><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是ioc-什么是di" class="router-link-active router-link-exact-active">什么是IOC？什么是DI？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何将一个类交给spring管理" class="router-link-active router-link-exact-active">如何将一个类交给Spring管理？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beandefinition是什么" class="router-link-active router-link-exact-active">BeanDefinition是什么？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beandefinitionreader是什么" class="router-link-active router-link-exact-active">BeanDefinitionReader是什么？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beandefinitionscanner是什么" class="router-link-active router-link-exact-active">BeanDefinitionScanner是什么？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beandefinitionregistry是什么" class="router-link-active router-link-exact-active">BeanDefinitionRegistry是什么？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#beanfactory是什么" class="router-link-active router-link-exact-active">BeanFactory是什么？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring上下文和beanfactory有什么区别" class="router-link-active router-link-exact-active">Spring上下文和BeanFactory有什么区别？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是factorybean" class="router-link-active router-link-exact-active">什么是FactoryBean？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-ioc容器的加载过程是怎样的" class="router-link-active router-link-exact-active">Spring IOC容器的加载过程是怎样的？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#bean的加载过程-生命周期-是怎样的" class="router-link-active router-link-exact-active">Bean的加载过程(生命周期)是怎样的？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-ioc都有哪些扩展点" class="router-link-active router-link-exact-active">Spring IOC都有哪些扩展点？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么某些情况下-value注入不了" class="router-link-active router-link-exact-active">为什么某些情况下@Value注入不了？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#" class="router-link-active router-link-exact-active"></a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#有哪些方式可以将bean对象给到spring容器中" class="router-link-active router-link-exact-active">有哪些方式可以将Bean对象给到Spring容器中？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring的单例bean线程是安全的吗-todo" class="router-link-active router-link-exact-active">Spring的单例Bean线程是安全的吗？todo</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-ioc容器如何解析配置类" class="router-link-active router-link-exact-active">Spring IOC容器如何解析配置类？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#带有-configuration和不带-configuration有什么区别" class="router-link-active router-link-exact-active">带有@Configuration和不带@Configuration有什么区别？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#componentscan如何被解析的" class="router-link-active router-link-exact-active">@ComponentScan如何被解析的？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是循环依赖" class="router-link-active router-link-exact-active">什么是循环依赖？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#循环依赖解决的大致思路" class="router-link-active router-link-exact-active">循环依赖解决的大致思路？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么需要二级缓存和三级缓存-分别是做什么的" class="router-link-active router-link-exact-active">为什么需要二级缓存和三级缓存？分别是做什么的？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-如何解决的循环依赖问题" class="router-link-active router-link-exact-active">Spring 如何解决的循环依赖问题？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring有没有解决构造函数的循环依赖" class="router-link-active router-link-exact-active">Spring有没有解决构造函数的循环依赖？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring有没有解决多例模式下的循环依赖" class="router-link-active router-link-exact-active">Spring有没有解决多例模式下的循环依赖？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何创建一个spring监听器" class="router-link-active router-link-exact-active">如何创建一个Spring监听器？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring事件监听机制是什么" class="router-link-active router-link-exact-active">Spring事件监听机制是什么？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-aop" class="router-link-active router-link-exact-active">Spring AOP</a><ul><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-aop的实现原理" class="router-link-active router-link-exact-active">Spring AOP的实现原理？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-事务机制" class="router-link-active router-link-exact-active">Spring 事务机制</a><ul><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring事务的传播行为" class="router-link-active router-link-exact-active">Spring事务的传播行为</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-事务的实现原理" class="router-link-active router-link-exact-active">Spring 事务的实现原理</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么内部方法调用事务会失效" class="router-link-active router-link-exact-active">为什么内部方法调用事务会失效？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-mvc" class="router-link-active router-link-exact-active">Spring MVC</a><ul><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-mvc的执行流程以及核心组件" class="router-link-active router-link-exact-active">Spring MVC的执行流程以及核心组件？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#spring-容器和spring-mvc容器是什么关系" class="router-link-active router-link-exact-active">Spring 容器和Spring MVC容器是什么关系？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis" class="router-link-active router-link-exact-active">Mybatis</a><ul><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis的整体架构" class="router-link-active router-link-exact-active">Mybatis的整体架构</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#什么是mybaits的一级缓存和二级缓存" class="router-link-active router-link-exact-active">什么是Mybaits的一级缓存和二级缓存？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何解析配置文件" class="router-link-active router-link-exact-active">Mybatis如何解析配置文件？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何解析sql" class="router-link-active router-link-exact-active">Mybatis如何解析Sql？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何实现参数映射" class="router-link-active router-link-exact-active">Mybatis如何实现参数映射？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何解析查询结果" class="router-link-active router-link-exact-active">Mybatis如何解析查询结果？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何执行数据查询" class="router-link-active router-link-exact-active">Mybatis如何执行数据查询？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis的插件-plugin-执行原理是什么" class="router-link-active router-link-exact-active">Mybatis的插件(Plugin)执行原理是什么？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#mybatis如何利用spring扩展点进行整合" class="router-link-active router-link-exact-active">Mybatis如何利用Spring扩展点进行整合？</a></li></ul></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot" class="router-link-active router-link-exact-active">SpringBoot</a><ul><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#import的用法" class="router-link-active router-link-exact-active">@Import的用法？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#为什么springboot不使用importselector的方式注入配置类" class="router-link-active router-link-exact-active">为什么SpringBoot不使用ImportSelector的方式注入配置类？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#deferredimportselector对bean的加载顺序的影响" class="router-link-active router-link-exact-active">DeferredImportSelector对Bean的加载顺序的影响？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot自动装配原理" class="router-link-active router-link-exact-active">SpringBoot自动装配原理？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#如何实现一个自定义的starter完成自动装配" class="router-link-active router-link-exact-active">如何实现一个自定义的Starter完成自动装配？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot为什么jar包可以直接运行" class="router-link-active router-link-exact-active">SpringBoot为什么Jar包可以直接运行？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot如何启动spring容器" class="router-link-active router-link-exact-active">SpringBoot如何启动Spring容器？</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#springboot的spi机制和java的spi机制有什么区别-todo-springboot的题需要从网上找一下答案。" class="router-link-active router-link-exact-active">SpringBoot的SPI机制和Java的SPI机制有什么区别？ todo springboot的题需要从网上找一下答案。</a></li><li><a aria-current="page" href="/docs/questions/%E6%A1%86%E6%9E%B6%E4%B8%AD%E9%97%B4%E4%BB%B6%E9%9D%A2%E8%AF%95%E9%A2%98.html#如果是自身维护starter组件-是不需要维护spring-factories文件的-这个文件统一配置在spring-boot-configuration包里-如果需要加载的一些组件用不到-需不需要把这里面的组件全部加载-todo" class="router-link-active router-link-exact-active">如果是自身维护Starter组件，是不需要维护spring.factories文件的，这个文件统一配置在spring-boot-configuration包里，如果需要加载的一些组件用不到，需不需要把这里面的组件全部加载？todo</a></li></ul></li></ul></nav><hr><h2 id="spring-ioc-容器" tabindex="-1"><a class="header-anchor" href="#spring-ioc-容器" aria-hidden="true">#</a> Spring IOC 容器</h2><h3 id="什么是ioc-什么是di" tabindex="-1"><a class="header-anchor" href="#什么是ioc-什么是di" aria-hidden="true">#</a> 什么是IOC？什么是DI？</h3><p>  IOC指的是控制反转，是一种设计思想。正常情况下，我们使用一个对象或者使用一个Bean，是由用户通过声明的方式来加载和使用的，是由用户进行控制的。SpringIOC首先是一个容器，Spring使用容器来创建和管理Bean，用户只需要通过一定的手段获取和使用Bean即可。IOC可以解决代码层级之间的耦合问题。</p><p>  DI是指的依赖注入，是Spring对IOC容器的一种实现，@Autowire就是DI的注解方式。同时Spring支持以来查找，可以通过Spring上下文来getBean。</p><h3 id="如何将一个类交给spring管理" tabindex="-1"><a class="header-anchor" href="#如何将一个类交给spring管理" aria-hidden="true">#</a> 如何将一个类交给Spring管理？</h3><ol><li>可以通过注解或者xml的方式声明一个Spring Bean。</li><li>通过加载Spring上下文(xxxApplicationContext)将声明的Bean配置加载到Spring容器中。</li><li>通过依赖注入或者依赖查找就可以获取到Bean。</li></ol><h3 id="beandefinition是什么" tabindex="-1"><a class="header-anchor" href="#beandefinition是什么" aria-hidden="true">#</a> BeanDefinition是什么？</h3><p>  Bean的配置方式有很多种，需要一个统一的方式交给BeanFactory用于生产Bean。BeanDefinition就是保存Bean配置信息的接口，它会保存Bean的装配信息、字段信息等等，用于BeanFactory反射生成Bean。</p><h3 id="beandefinitionreader是什么" tabindex="-1"><a class="header-anchor" href="#beandefinitionreader是什么" aria-hidden="true">#</a> BeanDefinitionReader是什么？</h3><p>  Spring Context通过扫描配置或者扫描注解的方式来加载Bean。BeanDefinitionReader就是用于读取Bean配置。</p><h3 id="beandefinitionscanner是什么" tabindex="-1"><a class="header-anchor" href="#beandefinitionscanner是什么" aria-hidden="true">#</a> BeanDefinitionScanner是什么？</h3><p>  Spring Context在项目启动时读取到的Bean配置有的是有效的有的是无效的，需要通过扫描识别出需要进行加载的Bean配置，BeanDefinitionScanner就是进行扫描甄别的。</p><h3 id="beandefinitionregistry是什么" tabindex="-1"><a class="header-anchor" href="#beandefinitionregistry是什么" aria-hidden="true">#</a> BeanDefinitionRegistry是什么？</h3><p>  Spring Context利用BeanDefinitionRegistry，将不同的配置方式读取并封装为BeanDefinition，存入ConcurrentHashMap中，提供给BeanFactory使用。</p><h3 id="beanfactory是什么" tabindex="-1"><a class="header-anchor" href="#beanfactory是什么" aria-hidden="true">#</a> BeanFactory是什么？</h3><p>  BeanFactory是Spring的顶层核心接口，使用简单工厂模式生产Bean并且提供一些扩展机制，用于在bean的生命周期中调用我们的扩展来处理Bean：</p><ul><li>Spring容器启动阶段：主要是注册Bean，并提供扩展接口 <ol><li>根据BeanDefinition生产Bean，并保存到缓存中。</li><li>BeanFactory定义了一个BeanFactoryPostProcessor接口允许我们扩展。</li></ol></li><li>bean实例化阶段：主要是提供扩展接口 <ol><li>提供各种Aware扩展接口：对于实现了Aware接口的Bean，实例化Bean时Spring会帮我们一块儿注入BeanFactory实例。</li><li>提供BeanPostProcessor接口：Spring实例化bean时会调用BeanPostProcessor接口中的方法。</li><li>InitializingBean接口：Spring实例化bean时进行调用。</li><li>DisposableBean接口：Spring实例化bean时进行调用。</li></ol></li></ul><h3 id="spring上下文和beanfactory有什么区别" tabindex="-1"><a class="header-anchor" href="#spring上下文和beanfactory有什么区别" aria-hidden="true">#</a> Spring上下文和BeanFactory有什么区别？</h3><p>  Spring上下文即ApplicationContext，它实现了BeanFactory，也就是说Spring上下文是BeanFactory的一种实现，具备BeanFactory定义BeanDefinition和生产Bean的能力。除此之外，Spring上下文包含了BeanDefinitionReader、BeanDefinitionScanner、以及上下文生命周期的各种实现，可以进行扫描、事件、国际化等等Spring容器相关的功能。</p><p>  BeanFactory只能注册BeanDefinition和生产Bean，并不能扫描。</p><h3 id="什么是factorybean" tabindex="-1"><a class="header-anchor" href="#什么是factorybean" aria-hidden="true">#</a> 什么是FactoryBean？</h3><p>  FactoryBean是一个接口。Bean在SpringIOC容器进行实例化时，有两种方式，一种是反射，另一种是通过工厂方式。</p><p>  FactoryBean就是实现工厂方式实例化Bean的接口。实现接口的Bean可以通过接口getObject()方法自定义Bean实例化的过程。</p><h3 id="spring-ioc容器的加载过程是怎样的" tabindex="-1"><a class="header-anchor" href="#spring-ioc容器的加载过程是怎样的" aria-hidden="true">#</a> Spring IOC容器的加载过程是怎样的？</h3><ol><li>准备工作：注册内置的PostProcessor(用于IOC容器加载不同的功能)、注册BeanDefinitionReader、BeanDefinitionScanner、BeanDefinitionRegistry。</li><li>调用BeanDefinitionPostProcessor注册BeanDefinition： <ol><li>BeanDefinitionReader读取项目指定范围下的配置类。</li><li>BeanDefinitionScanner扫描配置类，确定出需要装配Bean的范围。</li><li>BeanDefinitionRegistry将扫描到的有效的配置类注册为BeanDefinition，并保存到BeanFactory的内存(ConcurrentHashMap)中。</li></ol></li><li>注册Bean的后置处理器BeanPostProcessor。</li><li>初始化国际化资源。</li><li>创建事件多播器。</li><li>刷新容器，SpringBoot启动。</li><li>将事件监听器注册到事件多播器。</li><li>实例化单例Bean(非抽象、单例、不是懒加载)： <ol><li>BeanFactory根据BeanDefinition集合，在getBean()方法中利用反射<strong>实例化</strong>Bean。</li><li>BeanFactory将实例化后的Bean进行属性填充。(循环依赖的问题就出现在属性填充阶段)</li><li>BeanFactory对Bean进行初始化，执行init()、destory()等方法。</li><li>将初始化后的Bean存储一级缓存(单例池)中。</li></ol></li><li>最后刷新容器，SpringCloud启动。</li></ol><h3 id="bean的加载过程-生命周期-是怎样的" tabindex="-1"><a class="header-anchor" href="#bean的加载过程-生命周期-是怎样的" aria-hidden="true">#</a> Bean的加载过程(生命周期)是怎样的？</h3><ol><li>Bean的实例化：Bean实例化可以有两种方法，反射和工厂。 <ul><li>反射：由Spring控制的，利用Java的反射机制，通过BeanDefinition的信息，实例化Bean。</li><li>工厂方法：在配置Bean的时候，可以设置FactoryBean，如@Component中配置FactoryBean的实现类，这个类可以自己实现，用于生产这个Bean，因此是由用户控制的。包括@Bean的方式也是工厂方法，因为在方法中是我们自己return的new Bean()实例。</li></ul></li><li>Bean的属性填充。循环依赖问题就出现在Bean填充属性的阶段。</li><li>初始化Bean：调用initMethod、destroy方法等。</li><li>将Bean注册到一级缓存(单例池)中：Map&lt;beanName,Bean&gt;。</li><li>通过getBean()从一级缓存中获取到Bean。</li></ol><h3 id="spring-ioc都有哪些扩展点" tabindex="-1"><a class="header-anchor" href="#spring-ioc都有哪些扩展点" aria-hidden="true">#</a> Spring IOC都有哪些扩展点？</h3><p>  SpringIOC提供了两类后置处理器的扩展，一类是Spring Context提供的再容器加载用的后置处理器，在Bean加载之前调用，专门用于扩展BeanDefinition，这部分BeanFactory没有实现：</p><ul><li>BeanFactoryPostProcessor：BeanFactory的后置处理器 <ul><li>时机：Bean加载之前。</li><li>作用：可以获取到BeanFactory，主要用于修改BeanDefinition。</li></ul></li><li>BeanDefinitionRegistryPostProcessor：BeanDefinition注册后置处理器 <ul><li>时机：Bean加载之前。</li><li>作用：可以获取到BeanFactoryRegistry，可以手动注册BeanDefinition到BeanFactory。Mapper的动态代理就是通过这里注入的BeanDefinition。</li></ul></li></ul><p>  另一部分是BeanFactory实现的贯穿Bean生命周期9个后置处理器，都叫做BeanPostProcessor，专门用于扩展Bean：</p><ul><li>InstantiationAwareBeanPostProcessor#Before： <ul><li>时机：Bean实例化之前。</li><li>作用：停止创建Bean或者自己返回自己创建的Bean，在AOP中用于解析切面Aspect。</li></ul></li><li>SmartInstantiationAwareBeanPostProcessor： <ul><li>时机：Bean实例化时。</li><li>作用：指定实例化Bean的构造函数。</li></ul></li><li>MergedBeanDefinitionPostProcessor： <ul><li>时机：Bean属性填充之前。</li><li>作用：预解析@Autowired、@Value。</li></ul></li><li>SmartInstantiationAwareBeanPostProcessor： <ul><li>时机：Bean属性填充之前。</li><li>作用：解决循环引用AOP。</li></ul></li><li>InstantiationAwareBeanPostProcessor： <ul><li>时机：Bean属性填充时。</li><li>作用：终止赋值。</li></ul></li><li>InstantiationAwareBeanPostProcessor： <ul><li>时机：Bean属性填充时。</li><li>作用：注入属性PropertyValues(yml中的属性会被读为PropertyValues)，@Autowired也在这里DI。</li></ul></li><li>BeanPostProcessor#Before： <ul><li>时机：Bean初始化之前。</li><li>作用：执行@PostConstruct。</li></ul></li><li>BeanPostProcessor#After： <ul><li>时机：Bean初始化之后。</li><li>作用：创建AOP代理。</li></ul></li><li>DestructionAwareBeanPostProcessor： <ul><li>时机：初始化之后。</li><li>作用：销毁已经创建的Bean。</li></ul></li></ul><p>  除了后置处理器，还可以在Bean的所在类中，实现FactoryBean接口，并实现相关方法，来自定义Bean的实例化过程。</p><h3 id="为什么某些情况下-value注入不了" tabindex="-1"><a class="header-anchor" href="#为什么某些情况下-value注入不了" aria-hidden="true">#</a> 为什么某些情况下@Value注入不了？</h3><h3 id="" tabindex="-1"><a class="header-anchor" href="#" aria-hidden="true">#</a></h3><h3 id="有哪些方式可以将bean对象给到spring容器中" tabindex="-1"><a class="header-anchor" href="#有哪些方式可以将bean对象给到spring容器中" aria-hidden="true">#</a> 有哪些方式可以将Bean对象给到Spring容器中？</h3><p>  5种：</p><ul><li>@Configuration + @Bean注解：使用的是工厂Bean注入</li><li>@Component：使用的是扫描的方式</li><li>@Import注解：配置时注入</li><li>实现ImportSelector接口</li><li>BeanDefinitionRegistryPostProcessor</li><li>实现FactoryBean</li></ul><h3 id="spring的单例bean线程是安全的吗-todo" tabindex="-1"><a class="header-anchor" href="#spring的单例bean线程是安全的吗-todo" aria-hidden="true">#</a> Spring的单例Bean线程是安全的吗？todo</h3><p>  与是否单例关系不大，这个需要我们声明Bean的具体逻辑中自己设定。 如果我们设定的这个Bean是线程安全的，那么它就是线程安全的；反之，如果我们设定的Bean不是线程安全的，那么它就不是线程安全的。</p><h3 id="spring-ioc容器如何解析配置类" tabindex="-1"><a class="header-anchor" href="#spring-ioc容器如何解析配置类" aria-hidden="true">#</a> Spring IOC容器如何解析配置类？</h3><p>  Spring IOC容器加载过程的准备阶段，会加载一个专门解析配置类相关的BeanFactoryPostProcessor，@Configuration、@ComponentScan、@Import等等注解都是由这个后置处理器进行解析。</p><p>  解析时，会按顺序依次解析属性资源文件@PropertySource、 @ComponentScan、@Import、@ImportResource、@Bean。</p><p>  在实例化时，使用cglib对配置类进行动态代理。之所以使用动态代理，主要是为了解决在配置类中使用@Bean。动态代理中做了一部分增强逻辑：</p><ul><li>首先使用getBean从Spring IOC中获取bean。</li><li>获取不到才进行方法的实际创建。</li><li>创建完成后将@Bean方法创建的对象注册到容器中。</li></ul><h3 id="带有-configuration和不带-configuration有什么区别" tabindex="-1"><a class="header-anchor" href="#带有-configuration和不带-configuration有什么区别" aria-hidden="true">#</a> 带有@Configuration和不带@Configuration有什么区别？</h3><p>  Spring IOC容器在使用内置BeanFactoryPostProcessor解析配置类时，会判断配置类是否带有@Configuration注解。如果带有@Configuration就认为是一个完整的配置类。如果没有此注解，而是带有@Bean和@Component注解，则认为是不完整的配置类。</p><h3 id="componentscan如何被解析的" tabindex="-1"><a class="header-anchor" href="#componentscan如何被解析的" aria-hidden="true">#</a> @ComponentScan如何被解析的？</h3><p>  在解析配置了时，会循环所有的@ComponentScan，判断包含的类集合和需要排除的类集合，并将所有的包合并起来，最终得到一个需要扫描路径。</p><p>  BeanDefinitionScanner就是根据这个扫描路径扫描包下的所有类，找到所有的候选的BeanDefinition(扫描路径下不被排除的带有@Component族系注解的类都是候选)。</p><p>  最终BeanFactory利用BeanDefinitionRegistry会把扫描到的候选BeanDefinition注册到Map中。</p><h3 id="什么是循环依赖" tabindex="-1"><a class="header-anchor" href="#什么是循环依赖" aria-hidden="true">#</a> 什么是循环依赖？</h3><p>  循环依赖指的是Bean A依赖Bean B，同时Bean B又依赖Bean A。那么在创建Bean A时发现依赖了Bean B，那么就会先去创建Bean B，但是此时发现B又依赖了A，进入了死循环。</p><p>  循环依赖发生在Bean加载过程中的属性赋值阶段，会递归的加载所依赖的Bean。如果不解决这个问题，就会产生死循环。</p><h3 id="循环依赖解决的大致思路" tabindex="-1"><a class="header-anchor" href="#循环依赖解决的大致思路" aria-hidden="true">#</a> 循环依赖解决的大致思路？</h3><p>  循环依赖问题的产生其实就是产生了死循环。解决循环依赖其实就是在死循环中加一个出口就好了。解决这个问题的核心思路是，在Bean加载过程中，属性赋值之前，就将要加载的这个Bean先放入一级缓存中，也就是单例池中，这样在属性赋值时递归加载依赖Bean时，所依赖的Bean再回头获取时，就可以从缓存池中取到。</p><h3 id="为什么需要二级缓存和三级缓存-分别是做什么的" tabindex="-1"><a class="header-anchor" href="#为什么需要二级缓存和三级缓存-分别是做什么的" aria-hidden="true">#</a> 为什么需要二级缓存和三级缓存？分别是做什么的？</h3><p>  如果只有一级缓存，在多线程的情况下，Bean在加载过程的初期，一级缓存中的Bean实际上是个不完整的Bean，如果Bean没有创建完成，被另一个线程拿到，实际上是没法用的。那么此时需要二级缓存来暂存不完整的Bean。</p><p>  所以二级缓存存放循环依赖的没有创建完成的Bean。</p><p>  如果此时A使用了AOP，那么需要给A创建动态代理，动态代理在Bean初始化后使用BeanPostProcessor创建。初始化是在属性赋值之后做的，创建动态代理的过程在这后面，正常情况下是没有问题的，但是如果出现循环依赖，那么属性赋值时B依赖的A就不是动态代理对象了。</p><p>  所以为了能够提前识别此Bean是循环依赖的问题，对象实例化之前，首先判断二级缓存中是否有实例，有则代表是循环依赖。同时为了职责单一，将AOP动态代理对象的创建时机不变，因此将需要创建动态代理的循环依赖Bean的函数接口存入三级缓存，在创建时直接调用接口。</p><p>  因此三级缓存是存放循环依赖的Bean创建动态代理的接口的。</p><h3 id="spring-如何解决的循环依赖问题" tabindex="-1"><a class="header-anchor" href="#spring-如何解决的循环依赖问题" aria-hidden="true">#</a> Spring 如何解决的循环依赖问题？</h3><p>  Spring解决循环依赖使用的是三级缓存，就是三个ConcurrentHashMap。</p><p>  循环依赖产生的原因：循环依赖问题的产生其实就是产生了死循环。解决循环依赖其实就是在死循环中加一个出口就好了。解决这个问题的核心思路是，在Bean加载过程中，属性赋值之前，就将要加载的这个Bean先放入一级缓存中，也就是单例池中，这样在属性赋值时递归加载依赖Bean时，所依赖的Bean再回头获取时，就可以从缓存池中取到。</p><p>  如果只有一级缓存，在多线程的情况下，Bean在加载过程的初期，一级缓存中的Bean实际上是个不完整的Bean，如果Bean没有创建完成，被另一个线程拿到，实际上是没法用的。那么此时需要二级缓存来暂存不完整的Bean。</p><p>  所以二级缓存存放循环依赖的没有创建完成的Bean。</p><p>  如果此时A使用了AOP，那么需要给A创建动态代理，动态代理在Bean初始化后使用BeanPostProcessor创建。初始化是在属性赋值之后做的，创建动态代理的过程在这后面，正常情况下是没有问题的，但是如果出现循环依赖，那么属性赋值时B依赖的A就不是动态代理对象了。</p><p>  所以为了能够提前识别此Bean是循环依赖的问题，对象实例化之前，首先判断二级缓存中是否有实例，有则代表是循环依赖。同时为了职责单一，将AOP动态代理对象的创建时机不变，因此将需要创建动态代理的循环依赖Bean的函数接口存入三级缓存，在创建时直接调用接口。</p><p>  因此三级缓存是存放循环依赖的Bean创建动态代理的接口的。</p><h3 id="spring有没有解决构造函数的循环依赖" tabindex="-1"><a class="header-anchor" href="#spring有没有解决构造函数的循环依赖" aria-hidden="true">#</a> Spring有没有解决构造函数的循环依赖？</h3><p>  没有，构造函数是在Bean实例化时创建的，此时Bean的实例都没创建，因此也不会存在于一级缓存和二级缓存中，因此也没法判断是否是循环依赖，也无从解决。如果构造函数循环依赖，那么会报错。</p><h3 id="spring有没有解决多例模式下的循环依赖" tabindex="-1"><a class="header-anchor" href="#spring有没有解决多例模式下的循环依赖" aria-hidden="true">#</a> Spring有没有解决多例模式下的循环依赖？</h3><p>  多例模式不存在于一级缓存的单例池，毕竟不是单例的，每次使用创建一个实例即可，因此如果多例有循环依赖直接抛异常了。</p><h3 id="如何创建一个spring监听器" tabindex="-1"><a class="header-anchor" href="#如何创建一个spring监听器" aria-hidden="true">#</a> 如何创建一个Spring监听器？</h3><ul><li>实现事件：继承ApplicationEvent。</li><li>实现监听器：实现ApplicationListener&lt;ApplicationEvent&gt;接口，接口中的方法就是监听对应事件的方法。或者使用@EventListener(ApplicationEvent.class)</li><li>发布事件：使用Spring上下文ApplicationContext.publishEvent()发布事件。</li></ul><p>  大的分布式项目一般用MQ了，小的项目一般也用不到。很多是用于框架集成使用，如Nacos通过异步监听的方式进行配置推送和服务变更推送。</p><h3 id="spring事件监听机制是什么" tabindex="-1"><a class="header-anchor" href="#spring事件监听机制是什么" aria-hidden="true">#</a> Spring事件监听机制是什么？</h3><p>  Spring的事件监听采用的也是观察者模式，Spring上下文提供了事件发布的能力，用户通过实现事件和实现监听器完成订阅。</p><p>  监听器加载是在Spring IOC容器加载时完成的：</p><ol><li>首先，Spring IOC容器会将我们声明的监听器注册到多播器上，包括注解实现的和接口实现的所有监听器。</li><li>多播器广播原理： <ol><li>调用ApplicationContext的事件发布接口，会从容器中拿到多播器</li><li>在多播器中根据发布的事件类型，找到对应的监听器</li><li>如果多播器在配置类中设置了异步的Executor，那么会使用使用异步的方式开启一个新线程执行监听逻辑。</li><li>如果没有指定异步多播器，那么会同步执行。</li></ol></li></ol><h2 id="spring-aop" tabindex="-1"><a class="header-anchor" href="#spring-aop" aria-hidden="true">#</a> Spring AOP</h2><h3 id="spring-aop的实现原理" tabindex="-1"><a class="header-anchor" href="#spring-aop的实现原理" aria-hidden="true">#</a> Spring AOP的实现原理？</h3><p>  Spring在实现AOP时，如果使用的接口，用的JDK的动态代理实现，如果没有使用接口，则是使用的CGLIB实现。JDK的动态代理是通过JVM修改字节码的方式实现的，CGLIB是利用ASM库修改字节码的方式实现的。Spring AOP提供了AspectJ的支持。</p><p>  代理对象的生成主要包含了两个大步骤，一个是解析切面，一个是根据切面生成代理。</p><p>  在Spring IOC容器加载时，在第一个BeanPostProcessor中解析切面，为每一个带有@Aspectj注解的Bean生成一个Advicor。</p><p>  在Spring IOC容器初始化Bean后，会有一个BeanPostProcessor用于创建AOP代理：</p><ol><li>获取到所有解析过的Advicor。</li><li>拿到每一个Advicor的Pointcut。</li><li>利用Pointcut设置的方法名匹配Bean的方法名，匹配(策略模式)上说明可以创建动态代理。</li><li>为Bean创建动态代理对象。</li><li>将代理对象存入一级缓存。</li></ol><p>  在调用时，会把所有的增强Advicor转换为Interceptor，用责任链模式依次调用前置、未增强方法、后置、环绕。</p><h2 id="spring-事务机制" tabindex="-1"><a class="header-anchor" href="#spring-事务机制" aria-hidden="true">#</a> Spring 事务机制</h2><h3 id="spring事务的传播行为" tabindex="-1"><a class="header-anchor" href="#spring事务的传播行为" aria-hidden="true">#</a> Spring事务的传播行为</h3><ul><li>REQUIRED(默认级别)： <ul><li>外部不存在事务时：开启新事务。</li><li>外部存在事务时：融合到外部事务中，与外部事务组成同一个事务。</li><li>场景：增删改查。</li></ul></li><li>SUPPORTS： <ul><li>外部不存在事务时：不开启新事务。</li><li>外部存在事务时：融合到外部事务中。</li><li>场景：查询。</li></ul></li><li>REQUIRES_NEW： <ul><li>外部不存在事务时：开启新事务。</li><li>外部存在事务时：挂起外部事物，创建此事务范围的新事务。</li><li>场景：内部事务与外部事务不兼容。</li></ul></li><li>NOT_SUPPORTED： <ul><li>外部不存在事务时：不开启新事务。</li><li>外部存在事务时：挂起外部事务。</li><li>场景：不常用，仅仅用于某些情况不适合事务处理时。</li></ul></li><li>NEVER： <ul><li>外部不存在事务：不开启新事务。</li><li>外部存在事务：报错。</li><li>场景：不常用，仅用于禁止事务的场景。</li></ul></li><li>MANDATORY： <ul><li>外部不存在事务：抛出异常。</li><li>外部存在事务：融合到外部事务。</li><li>场景：不常用，仅用于高层级接口规定的事务时。</li></ul></li><li>NESTED： <ul><li>外部不存在事务时：开启新事务。</li><li>外部存在事务时：SavePoint机制，把内层事务单独看做一个原子操作融合到外层。</li><li>场景：不常用。</li></ul></li></ul><h3 id="spring-事务的实现原理" tabindex="-1"><a class="header-anchor" href="#spring-事务的实现原理" aria-hidden="true">#</a> Spring 事务的实现原理</h3><p>  Spring声明式事务是基于Spring AOP的机制实现的，同样需要加载切面、创建代理和调用代理。事务增强的传播行为等逻辑，是Spring内置好的一套逻辑。</p><p>  在Spring IOC容器加载时的准备阶段，利用内置的BeanFactoryPostProcessor<strong>解析配置类时</strong>会解析@Import注解，与事务相关的注册动作有2个：</p><ul><li>注册一个BeanPostProcessor，用于生成事务代理Bean。</li><li>注册一个与事务相关的Advicor的Bean。</li></ul><p>  事务代理切面的解析与AOP相同，在第一个BeanPostProcessor中，调用的实现就是上述注册的实现，但是由于Advicor是内置的而且在准备阶段已经注册，因此在这里直接将上一步的Advicor放入Advicor的集合中，给生成代理的PostProcessor使用。</p><p>  生成代理对象的BeanPostProcessor中，与事务相关的逻辑是这样的：</p><ol><li>Pointcut匹配方法时，匹配的是@Transaction注解的方法而不是方法名。</li><li>根据@Transaction注解生成注解属性实例，包含注解里设置的属性和修饰方法的全限定名。</li><li>根据属性信息为类创建事务代理对象，在事务的方法上做增强。</li></ol><p>  事务调用时，执行事务代理方法，对于没有事务嵌套的：</p><ol><li>使用TransactionManager开启事务</li><li>使用责任链执行具体的方法</li><li>catch异常执行回滚</li><li>没有问题执行完成执行提交</li></ol><p>  有嵌套事务时，会根据事务的传播行为判断开启事务的点。</p><h3 id="为什么内部方法调用事务会失效" tabindex="-1"><a class="header-anchor" href="#为什么内部方法调用事务会失效" aria-hidden="true">#</a> 为什么内部方法调用事务会失效？</h3><p>  Spring事务机制是基于AOP实现的，AOP的代理对象执行方法是利用责任链把before、环绕、方法本身、after这些增强依次执行的。</p><p>  使用内部方法调用时，仅仅是责任链中执行方法本身的那一环节invoke()方法而已，并不具备增强的逻辑。</p><h2 id="spring-mvc" tabindex="-1"><a class="header-anchor" href="#spring-mvc" aria-hidden="true">#</a> Spring MVC</h2><h3 id="spring-mvc的执行流程以及核心组件" tabindex="-1"><a class="header-anchor" href="#spring-mvc的执行流程以及核心组件" aria-hidden="true">#</a> Spring MVC的执行流程以及核心组件？</h3><p>  SpringMVC有以下几个核心组件：</p><ul><li>DispatcherServlet：前端控制器。</li><li>HandlerMapping：处理器映射器。</li><li>HandlerAdapter：处理器适配器。</li><li>Controller：控制器。</li><li>ViewResoler：视图解析器。</li></ul><p>  SpringMVC处理请求的大致流程是这样的：</p><ol><li>客户端发送请求，被DispatcherServlet接收。</li><li>DispatcherServlet交给HandlerMapping查询执行链路Chain，包括Interceptor链路和Controller。</li><li>DispatcherServlet把请求和执行链路交给HandlerAdapter负责执行。</li><li>Controller返回ModelAndView给HandlerAdapter。</li><li>DispatcherServlet将ModelAndView交给ViewResolver解析为View，然后返回给客户端。</li></ol><h3 id="spring-容器和spring-mvc容器是什么关系" tabindex="-1"><a class="header-anchor" href="#spring-容器和spring-mvc容器是什么关系" aria-hidden="true">#</a> Spring 容器和Spring MVC容器是什么关系？</h3><p>  Spring容器是管理Spring Bean的地方，通俗的理解，@Service、@Mapper等都是Spring 容器管理。@Controller则是由Spring MVC的容器管理。类似的还有LoadBalancer的容器、OpenFeign的容器，分别管理自己的Bean的实现。</p><h2 id="mybatis" tabindex="-1"><a class="header-anchor" href="#mybatis" aria-hidden="true">#</a> Mybatis</h2><h3 id="mybatis的整体架构" tabindex="-1"><a class="header-anchor" href="#mybatis的整体架构" aria-hidden="true">#</a> Mybatis的整体架构</h3><p>  Mybatis分为三层，由顶向下分别是：接口层、数据处理层、基础支撑层。</p><ul><li>接口层：由<strong>SqlSession</strong>提供了增删改查等一系列的数据操作接口。</li><li>数据处理层：参数映射(ParameterHandler)、Sql解析(SqlSource)、Sql执行(Executor)、结果映射(ResultSetHandler)。</li><li>基础支撑层：基于xml和注解的Sql语句配置、连接管理、事务管理、配置加载、缓存处理、配置架构。</li></ul><h3 id="什么是mybaits的一级缓存和二级缓存" tabindex="-1"><a class="header-anchor" href="#什么是mybaits的一级缓存和二级缓存" aria-hidden="true">#</a> 什么是Mybaits的一级缓存和二级缓存？</h3><p>  在一次Mybatis会话中，也就是一次SqlSession中，所有的查询操作都会保存到缓存中(一级缓存默认开启)。一般来说，一个请求中的所有增删改查操作都是由一个SqlSession完成的，因此可以认为每一个请求都有一个一级缓存。</p><p>  如果同一个操作中两次相同的查询中有一个update、insert、delete语句，那么一级缓存会被清除。因为每次对同一个表的增删改查操作都有可能修改数据，因此需要刷新缓存。</p><p>  一级缓存是针对会话的，二级缓存是全局的，需要手动开启。一个SqlSession会话关闭时，会将其一级缓存刷新到二级缓存中，当另一个SqlSession执行时，会首先查询二级缓存，当二级缓存不被命中时，才会查询数据库。</p><p>  每一条语句都有一个缓存key，value就是缓存结果。缓存key包含sql语句、参数、方法全限定路径。因此能够通过缓存key判断是否是同一条语句。一级缓存是保存在SqlSession的，因此能保证每一个会话都有其独立的一级缓存。</p><h3 id="mybatis如何解析配置文件" tabindex="-1"><a class="header-anchor" href="#mybatis如何解析配置文件" aria-hidden="true">#</a> Mybatis如何解析配置文件？</h3><p>  SqlSessionFactory通过加载配置文件，将其解析为Configuration对象，SqlSessionFactory中使用构造器模式，将xml文件属性全都读取为Configuration。</p><p>  Mybatis的构造器都实现了BaseBuilder接口，提供了有很多实现，用于解析不通的内容：MyBatis配置文件、Mybatis全局配置文件、Mapper、Sql语句、节点等。各种Builder会把对应的内容解析为Crud节点信息、结果映射、参数映射等存入Configuration。</p><p>  需要注意的是，解析Mapper的XML文件时，会解析二级缓存：</p><ol><li>解析&lt;cache&gt;标签配置，生成Cache对象。</li><li>使用装饰器模式把一层层的Cache缓存实现类装饰起来。</li><li>把缓存对象放到Configuration中。</li></ol><h3 id="mybatis如何解析sql" tabindex="-1"><a class="header-anchor" href="#mybatis如何解析sql" aria-hidden="true">#</a> Mybatis如何解析Sql？</h3><p>  Mybatis使用SqlSource解析Sql。在加载过程时，已经将Sql执行的所需要的节点信息等加载到了Configuration。Mybatis会使用责任链模式，依次解析所有的SqlNode，最终拼装为Sql存放在SqlSource中。</p><h3 id="mybatis如何实现参数映射" tabindex="-1"><a class="header-anchor" href="#mybatis如何实现参数映射" aria-hidden="true">#</a> Mybatis如何实现参数映射？</h3><p>  SqlSource解析Sql时，会将Sql标签中的参数替换为问号。当参数传入时，ParameterHandler根据参数找到对应的类型，并根据类型找到对应的TypeHandler。利用类型处理器将问号替换为对应参数名称的参数。</p><h3 id="mybatis如何解析查询结果" tabindex="-1"><a class="header-anchor" href="#mybatis如何解析查询结果" aria-hidden="true">#</a> Mybatis如何解析查询结果？</h3><p>  ResultSetHandler根据xml中设置的ResultSet的映射关系，依次解析查询到的ResultSet。</p><h3 id="mybatis如何执行数据查询" tabindex="-1"><a class="header-anchor" href="#mybatis如何执行数据查询" aria-hidden="true">#</a> Mybatis如何执行数据查询？</h3><p>  Mybatis的执行器(Executor)的实现有5种，分别是Simple、Reuse(重复)、Batch(批量)、Caching(开启二级缓存)、BaseExecutor(一级缓存)。Mybatis使用门面模式，将Simple、Reuse、Batch委托给Base和Caching，首先执行Base和Caching的修饰，再执行Simple、Reuse、Batch的具体逻辑。</p><h3 id="mybatis的插件-plugin-执行原理是什么" tabindex="-1"><a class="header-anchor" href="#mybatis的插件-plugin-执行原理是什么" aria-hidden="true">#</a> Mybatis的插件(Plugin)执行原理是什么？</h3><p>  Mybatis插件增强是通过动态代理增强底层的四个核心对象，以拦截器的形式进行增强，或者说指定需要拦截的类的方法，为方法创建动态代理。插件创建的时机是当SqlSessionFactory解析配置文件时，在Configuration创建四个核心对象时，遍历InterceptorChain为对应的类的方法创建动态代理。：</p><ul><li>Executor(执行器)：增强sql的增删查改方法、flushStatement、提交回滚等。相当于追加标签来拼接sql。</li><li>ParameterHandler(参数映射)：getParameterObjet、setParameter。</li><li>ResultSetHandler(结果映射)：增强handleResultSet、handleOutputParameter。</li><li>StatementHandler(sql执行者)：prepare、parameterize、batch、update、query。</li></ul><h3 id="mybatis如何利用spring扩展点进行整合" tabindex="-1"><a class="header-anchor" href="#mybatis如何利用spring扩展点进行整合" aria-hidden="true">#</a> Mybatis如何利用Spring扩展点进行整合？</h3><ol><li>初始化： <ol><li>通过自动装配注入SqlSessionFactoryBean。</li><li>SqlSessionFactoryBean构建SqlSessionFactory。</li><li>SqlSessionFactory将所有的配置加载到Configuration，并构建XmlMapperBuilder，用来解析XmlMapper。</li><li>SqlSessionFactoryBean注入Spring的TransactionManager获取Connection，并配置到Configuration。</li></ol></li><li>管理@Mapper动态代理： <ol><li>利用BeanDefinitionRegistryPostProcessor注册BeanDefinition。</li><li>Mybatis实现了一个自己的BeanDefinitionScanner，专门扫描@Mapper。</li><li>定义一个<strong>FactoryBean接口(大多数的框架集成都是用的这个)</strong>，将所有@Mapper接口都实现为FactoryBean，实现对所有@Mapper接口的动态代理。</li><li>在FactoryBean控制实例化时，拿到Configuration中的Xml配置信息，然后将动态代理的对象通过FactoryBean提供的getObject()方法返回给Spring容器。</li><li>通过定义BeanDefinition，生成@Mapper的Bean。</li></ol></li></ol><p>  也就是说，Mybatis在创建@Mapper类的动态代理过程是利用SpringIOC容器的扩展机制：</p><ul><li>BeanDefinitionRegistryPostProcessor将Mapper接口注册为Bean。</li><li>使用FactoryBean机制，使用动态代理把Bean对象转换为代理对象。</li></ul><h2 id="springboot" tabindex="-1"><a class="header-anchor" href="#springboot" aria-hidden="true">#</a> SpringBoot</h2><h3 id="import的用法" tabindex="-1"><a class="header-anchor" href="#import的用法" aria-hidden="true">#</a> @Import的用法？</h3><ul><li>@Import(Class)：将该类注册为一个Bean。</li><li>@Import(ImportSelector.class)：参数是实现了ImportSelector接口的类，通过返回一个类路径的数组，可以一次性注册很多Bean。</li></ul><h3 id="为什么springboot不使用importselector的方式注入配置类" tabindex="-1"><a class="header-anchor" href="#为什么springboot不使用importselector的方式注入配置类" aria-hidden="true">#</a> 为什么SpringBoot不使用ImportSelector的方式注入配置类？</h3><p>  主要是扩展性问题，使用@Import注解引入ImportSelector接口，虽然能够一次性的注入多个Bean，但是只能注入固定的Bean，用过用户需要加载自定义的框架配置类实现，通过SPI机制是可以做到很好的插拔效果的。</p><p>  其次，使用@ConditionOn注解来进行判断注入自定义还是默认的Bean，由于Bean注入的顺序无法控制，也无法完成用户注入自定义框架配置类实现的要求。</p><h3 id="deferredimportselector对bean的加载顺序的影响" tabindex="-1"><a class="header-anchor" href="#deferredimportselector对bean的加载顺序的影响" aria-hidden="true">#</a> DeferredImportSelector对Bean的加载顺序的影响？</h3><p>  DeferredImportSelector可以控制Bean注入的顺序。使用@Import注入Bean时，如果实现了DeferredImportSelector，那么用它注入的Bean时延迟加载的。</p><p>  在Spring IOC加载的准备阶段，会扫描注入配置类的BeanDefinition，包括@Bean、@Import等等，DeferredImportSelector会在所有的需要提前注入的Bean注入完成后，再延迟加载，其顺序是在后面的。</p><p>  另外，DeferredImportSelector提供了分组功能，会调用用户重写实现的分组功能，比如实现当前组内BeanDefinition注册时的顺序，整个组的注册会在SpringIOC加载配置Bean之后，因此顺序是可控的。</p><h3 id="springboot自动装配原理" tabindex="-1"><a class="header-anchor" href="#springboot自动装配原理" aria-hidden="true">#</a> SpringBoot自动装配原理？</h3><p>  SpringBoot利用@Import导入DeferredImportSelector延迟注册的原理。SpringBoot把需要加载的Bean都写在了META-INFO/Spring.factories文件中，在分组中读取文件中类的全限定名，然后注册为BeanDefinition。</p><p>  在加载spring.factories时，会根据条件进行过滤，如文件中配置为xxx.OnClassCondition的类时，就会判断是否生效。</p><h3 id="如何实现一个自定义的starter完成自动装配" tabindex="-1"><a class="header-anchor" href="#如何实现一个自定义的starter完成自动装配" aria-hidden="true">#</a> 如何实现一个自定义的Starter完成自动装配？</h3><ol><li>在自己实现的Starter中仙剑META-INFO/spring.factories</li><li>文件中指向自己的自动配置类全限定名：</li></ol><div class="language-properties ext-properties line-numbers-mode"><pre class="language-properties"><code><span class="token attr-name">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span><span class="token punctuation">=</span><span class="token attr-value">\
cn.demo.HelloAutoConfiguration</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ol start="3"><li>自己的自动配置类使用@Configuration注入，使用@ConditionalOnProperty配置生效规则，使用@EnableConfigurationProperties配置生效属性。</li></ol><h3 id="springboot为什么jar包可以直接运行" tabindex="-1"><a class="header-anchor" href="#springboot为什么jar包可以直接运行" aria-hidden="true">#</a> SpringBoot为什么Jar包可以直接运行？</h3><p>  通过添加spring-boot-maven-plugin插件，可以直接使用java -jar启动SpringBoot程序。插件会自动编写MANIFEST.MF文件，并且将依赖的Jar包打包到程序的Jar包中。</p><p>  MANIFEST.MF文件中，指定了项目的启动类、Jar包路径、MainClass等一系列信息。</p><p>  Java没有提供标准的ClassLoader加载嵌套的Jar文件，MainClass属性指定的就是SpringBoot项目加载类用的ClassLoader。使用Java -jar启动时使用的是指定的JarLaunch，会加载SpringBoot依赖的Jar包。</p><h3 id="springboot如何启动spring容器" tabindex="-1"><a class="header-anchor" href="#springboot如何启动spring容器" aria-hidden="true">#</a> SpringBoot如何启动Spring容器？</h3><p>  SpringBoot在启动时，SpringApplication初始化时(new SpringApplication)：</p><ol><li>初始化一个Spring容器(ApplicationContext)。</li><li>读取ApplicationListener监听器。</li></ol><p>  Spring容器启动的流程与之前说的相同。需要额外关注的是：</p><ul><li>Tomcat的初始化是在Spring容器的refresh中完成的。</li><li>在refresh方法中，会扫描spring.factories加载需要自动装配的类。</li></ul><p>  之后是执行run()方法：</p><ol><li>发布ApplicationStartingEvent，用于扩展SpringBoot</li><li>发布ApplicationEnvironmentPreparedEvent：通知监听器可以对配置文件进行读取操作了，读取配置文件就是基于监听器。</li><li>读取和封装环境配置信息，全部封装为@ConfigurationProperties。</li><li>实例化Spring上下文。</li><li>Spring容器加载： <ul><li>会额外发布一个ApplicationContextInitiatializedEvent。</li><li>将SpringBoot的监听器加载到多播器。</li><li>发布SpringApplicationPreparedEvent。</li></ul></li></ol><h3 id="springboot的spi机制和java的spi机制有什么区别-todo-springboot的题需要从网上找一下答案。" tabindex="-1"><a class="header-anchor" href="#springboot的spi机制和java的spi机制有什么区别-todo-springboot的题需要从网上找一下答案。" aria-hidden="true">#</a> SpringBoot的SPI机制和Java的SPI机制有什么区别？ todo springboot的题需要从网上找一下答案。</h3><p>  Java的SPI机制是一种服务发现机制，可以通过读取ClassPath下META-INFO/services文件，自动加载接口的类。</p><p>  SpringBoot的实现并不是利用SPI机制，只是借鉴了SPI的思想。JavaSPI的核心是，通过配置接口，自动找到实现类。SpringBoot则是配置实现类，去加载这些类，并注册到Spring的容器中。</p><h3 id="如果是自身维护starter组件-是不需要维护spring-factories文件的-这个文件统一配置在spring-boot-configuration包里-如果需要加载的一些组件用不到-需不需要把这里面的组件全部加载-todo" tabindex="-1"><a class="header-anchor" href="#如果是自身维护starter组件-是不需要维护spring-factories文件的-这个文件统一配置在spring-boot-configuration包里-如果需要加载的一些组件用不到-需不需要把这里面的组件全部加载-todo" aria-hidden="true">#</a> 如果是自身维护Starter组件，是不需要维护spring.factories文件的，这个文件统一配置在spring-boot-configuration包里，如果需要加载的一些组件用不到，需不需要把这里面的组件全部加载？todo</h3><p>  Condition条件。</p><!--]--></div><!----><footer class="page-meta"><div class="meta-item edit-link"><a href="https://github.com/noErrorNoBug/docs/edit/master/docs/questions/框架中间件面试题.md" rel="noopener noreferrer" target="_blank" arialabel="编辑此页" class="nav-link label"><!--[--><svg xmlns="http://www.w3.org/2000/svg" class="icon edit-icon" viewbox="0 0 1024 1024" arialabelledby="edit"><title id="edit" lang="en">edit icon</title><g fill="currentColor"><path d="M430.818 653.65a60.46 60.46 0 0 1-50.96-93.281l71.69-114.012 7.773-10.365L816.038 80.138A60.46 60.46 0 0 1 859.225 62a60.46 60.46 0 0 1 43.186 18.138l43.186 43.186a60.46 60.46 0 0 1 0 86.373L588.879 565.55l-8.637 8.637-117.466 68.234a60.46 60.46 0 0 1-31.958 11.229z"></path><path d="M728.802 962H252.891A190.883 190.883 0 0 1 62.008 771.98V296.934a190.883 190.883 0 0 1 190.883-192.61h267.754a60.46 60.46 0 0 1 0 120.92H252.891a69.962 69.962 0 0 0-69.098 69.099V771.98a69.962 69.962 0 0 0 69.098 69.098h475.911A69.962 69.962 0 0 0 797.9 771.98V503.363a60.46 60.46 0 1 1 120.922 0V771.98A190.883 190.883 0 0 1 728.802 962z"></path></g></svg><!--]-->编辑此页<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span><!----></a></div><div class="meta-item update-time"><span class="label">上次编辑于: </span><span class="info">2022/9/10 01:12:29</span></div><div class="meta-item contributors"><span class="label">贡献者: </span><!--[--><!--[--><span class="contributor" title="email: 749922109@qq.com">sunqiang</span><!--]--><!--]--></div></footer><nav class="page-nav"><a href="/docs/questions/数据存储中间件面试题.md" class="nav-link prev" arialabel="数据存储中间件面试题"><div class="hint"><span class="arrow left"></span>上一页</div><div class="link"><!---->数据存储中间件面试题</div></a><a href="/docs/questions/分布式和微服务面试题.md" class="nav-link next" arialabel="分布式和微服务面试题"><div class="hint">下一页<span class="arrow right"></span></div><div class="link">分布式和微服务面试题<!----></div></a></nav><div class="giscus-wrapper" style="display:none;"><!----></div><!----></main><!--]--><footer class="footer-wrapper"><div class="footer">Apache License 2.0 | Copyright © 2018-present noErrorNoBug(sunqiang)</div><!----></footer></div><!--]--><!----><!--[--><!-- Root element of PhotoSwipe. Must have class pswp. --><div class="pswp" tabindex="-1" role="dialog" aria-hidden="true"><!-- Background of PhotoSwipe. 
    It’s a separate element, as animating opacity is faster than rgba().--><div class="pswp__bg"></div><!-- Slides wrapper with overflow:hidden. --><div class="pswp__scroll-wrap"><!-- Container that holds slides. PhotoSwipe keeps only 3 slides in DOM to save memory. --><div class="pswp__container"><!-- don’t modify these 3 pswp__item elements, data is added later on --><div class="pswp__item"></div><div class="pswp__item"></div><div class="pswp__item"></div></div><!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. --><div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><!--  Controls are self-explanatory. Order can be changed. --><div class="pswp__counter"></div><button class="pswp__button pswp__button--close" title="关闭"></button><button class="pswp__button pswp__button--share" title="分享"></button><button class="pswp__button pswp__button--fs" title="切换全屏"></button><button class="pswp__button pswp__button--zoom" title="缩放"></button><!-- Preloader demo https://codepen.io/dimsemenov/pen/yyBWoR --><!-- element will get class pswp__preloader--active when preloader is running --><div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div><button class="pswp__button pswp__button--arrow--left" title="上一个 (左箭头)"></button><button class="pswp__button pswp__button--arrow--right" title="下一个 (右箭头)"></button><div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div><!--]--><!----><div id="pwa-install"><!----><div id="install-modal-wrapper" style="display:none;"><div class="background"></div><div class="install-modal"><div class="header"><button class="close-button" aria-label="关闭"><svg xmlns="http://www.w3.org/2000/svg" class="icon close-icon" viewbox="0 0 1024 1024" arialabelledby="close"><title id="close" lang="en">close icon</title><g fill="currentColor"><path d="M589.654 511.965 1007.212 84.22a49.777 49.777 0 0 0-.73-70.02 49.046 49.046 0 0 0-69.687.665L519.967 441.946 85.882 14.2a49.08 49.08 0 0 0-69.687.664 49.777 49.777 0 0 0 .664 70.019l433.454 427.082L16.859 939.048a49.777 49.777 0 0 0-.664 70.019 49.013 49.013 0 0 0 69.687.663l434.085-427.746 416.828 427.083A49.013 49.013 0 0 0 972.037 1024a48.416 48.416 0 0 0 34.512-14.27 49.777 49.777 0 0 0 .73-70.019z"></path></g></svg></button><div class="logo"><!--v-if--><div class="title"><h1></h1><p class="desc">该应用可以安装在你的 PC 或移动设备上。这将使该 Web 应用程序外观和行为与其他应用程序相同。它将在出现在应用程序列表中，并可以固定到主屏幕，开始菜单或任务栏。此 Web 应用程序还将能够与其他应用程序和你的操作系统安全地进行交互。</p></div></div></div><div class="content"><div class="highlight"><!--v-if--><!--v-if--></div><div class="description"><h3>详情</h3><p></p></div></div><div class="button-wrapper"><button class="install-button">安装 <span></span></button><button class="cancel-button">取消</button></div></div></div></div><!--]--></div>
    <script type="module" src="/docs/assets/app.7eb989d9.js" defer></script>
  </body>
</html>
